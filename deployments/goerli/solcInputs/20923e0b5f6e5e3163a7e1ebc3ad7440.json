{
  "language": "Solidity",
  "sources": {
    "contracts/adapters/YaxisVaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {IDetailedERC20} from \"../interfaces/IDetailedERC20.sol\";\nimport {IVaultAdapter} from \"../interfaces/IVaultAdapter.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IGauge} from \"../interfaces/IGauge.sol\";\nimport {IRewards} from \"../interfaces/IRewards.sol\";\n\n/// @title YaxisVaultAdapter\n///\n/// @dev A vault adapter implementation which wraps a yAxis vault.\ncontract YaxisVaultAdapter is IVaultAdapter {\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    /// @dev The vault that the adapter is wrapping.\n    IVault public immutable vault;\n\n    /// @dev The gauge of the vault that the adapter is wrapping.\n    IGauge public immutable gauge;\n\n    /// @dev The address which has admin control over this contract.\n    address public immutable admin;\n\n    /// @dev The address which will receive rewards.\n    address public immutable rewards;\n\n    /// @dev The token that the vault accepts\n    IDetailedERC20 public immutable override token;\n\n    /// @dev The token that the vault issued\n    IDetailedERC20 public immutable lpToken;\n\n    constructor(\n        IVault _vault,\n        address _admin,\n        address _rewards\n    ) public {\n        require(\n            _admin != address(0),\n            \"YaxisVaultAdapter: admin address cannot be 0x0.\"\n        );\n        require(\n            _rewards != address(0),\n            \"YaxisVaultAdapter: rewards address cannot be 0x0.\"\n        );\n\n        vault = _vault;\n        admin = _admin;\n        rewards = _rewards;\n\n        address _gauge = _vault.gauge();\n        IDetailedERC20 _token = IDetailedERC20(_vault.getToken());\n        IDetailedERC20 _lpToken = IDetailedERC20(_vault.getLPToken());\n        gauge = IGauge(_gauge);\n        token = _token;\n        lpToken = _lpToken;\n\n        _token.safeApprove(address(_vault), uint256(-1));\n        _lpToken.safeApprove(address(_gauge), uint256(-1));\n    }\n\n    /// @dev Gets the total value of the assets that the adapter holds in the vault.\n    ///\n    /// @return the total assets.\n    function totalValue() external view override returns (uint256) {\n        return _sharesToTokens(gauge.balanceOf(address(this)));\n    }\n\n    /// @dev Deposits tokens into the vault.\n    ///\n    /// @param _amount the amount of tokens to deposit into the vault.\n    function deposit(uint256 _amount) external override {\n        vault.deposit(_amount);\n        gauge.deposit(lpToken.balanceOf(address(this)));\n    }\n\n    /// @dev Withdraws tokens from the vault to the recipient.\n    ///\n    /// This function reverts if the caller is not the admin.\n    ///\n    /// @param _recipient the account to withdraw the tokes to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function withdraw(address _recipient, uint256 _amount) external override {\n        require(admin == msg.sender, \"YaxisVaultAdapter: only admin\");\n\n        IDetailedERC20 _token = token;\n        uint256 beforeBalance = _token.balanceOf(address(this));\n        uint256 share = _tokensToShares(_amount);\n\n        gauge.withdraw(share);\n        vault.withdraw(share);\n\n        _token.safeTransfer(\n            _recipient,\n            _token.balanceOf(address(this)) - beforeBalance\n        );\n    }\n\n    /// @dev Claim gauge rewards.\n    ///\n    function claimReward() external {\n        gauge.claim_rewards();\n        IDetailedERC20 rewardToken = IDetailedERC20(gauge.reward_tokens(0));\n        uint256 rewardBalance = rewardToken.balanceOf(address(this));\n        if (rewardBalance > 0) {\n            rewardToken.transfer(rewards, rewardBalance);\n            IRewards(rewards).notifyRewardAmount(rewardBalance);\n        }\n    }\n\n    /// @dev Computes the number of tokens an amount of shares is worth.\n    ///\n    /// @param _sharesAmount the amount of shares.\n    ///\n    /// @return the number of tokens the shares are worth.\n\n    function _sharesToTokens(uint256 _sharesAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return _sharesAmount.mul(vault.getPricePerFullShare()).div(1e18);\n    }\n\n    /// @dev Computes the number of shares an amount of tokens is worth.\n    ///\n    /// @param _tokensAmount the amount of shares.\n    ///\n    /// @return the number of shares the tokens are worth.\n    function _tokensToShares(uint256 _tokensAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return _tokensAmount.mul(1e18).div(vault.getPricePerFullShare());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IDetailedERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDetailedERC20 is IERC20 {\n  function name() external returns (string memory);\n  function symbol() external returns (string memory);\n  function decimals() external returns (uint8);\n}"
    },
    "contracts/interfaces/IVaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IDetailedERC20.sol\";\n\n/// Interface for all Vault Adapter implementations.\ninterface IVaultAdapter {\n\n  /// @dev Gets the token that the adapter accepts.\n  function token() external view returns (IDetailedERC20);\n\n  /// @dev The total value of the assets deposited into the vault.\n  function totalValue() external view returns (uint256);\n\n  /// @dev Deposits funds into the vault.\n  ///\n  /// @param _amount  the amount of funds to deposit.\n  function deposit(uint256 _amount) external;\n\n  /// @dev Attempts to withdraw funds from the wrapped vault.\n  ///\n  /// The amount withdrawn to the recipient may be less than the amount requested.\n  ///\n  /// @param _recipient the recipient of the funds.\n  /// @param _amount    the amount of funds to withdraw.\n  function withdraw(address _recipient, uint256 _amount) external;\n}"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVault {\n    function available() external view returns (uint256);\n\n    function balance() external view returns (uint256);\n\n    function deposit(uint256 _amount) external returns (uint256);\n\n    function earn(address _strategy) external;\n\n    function gauge() external returns (address);\n\n    function getLPToken() external view returns (address);\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function getToken() external view returns (address);\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawAll() external;\n\n    function withdrawFee(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IGauge {\n    function deposit(uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function withdraw(uint256) external;\n\n    function claim_rewards() external;\n\n    function reward_tokens(uint256) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRewards {\n    function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/VaultAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IVaultAdapter.sol\";\n\ncontract VaultAdapterMock is IVaultAdapter {\n  using SafeERC20 for IDetailedERC20;\n\n  IDetailedERC20 private _token;\n\n  constructor(IDetailedERC20 token_) public {\n    _token = token_;\n  }\n\n  function token() external view override returns (IDetailedERC20) {\n    return _token;\n  }\n\n  function totalValue() external view override returns (uint256) {\n    return _token.balanceOf(address(this));\n  }\n\n  function deposit(uint256 _amount) external override { }\n\n  function withdraw(address _recipient, uint256 _amount) external override {\n    _token.safeTransfer(_recipient, _amount);\n  }\n}\n"
    },
    "contracts/vendor/Rewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable reason-string\n// solhint-disable not-rely-on-time\n/**\n * This contract has been modified with:\n * - generalized for any reward token, staking token, and duration\n * - upgraded to Solidity 6\n * - support ERC677 transferAndCall\n * <3 Synthetix\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: CurveRewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract ERC677Receiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes memory _data\n    ) public virtual;\n}\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    address public rewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(\n            _msgSender() == rewardDistribution,\n            \"Caller is not reward distribution\"\n        );\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n        onlyOwner\n    {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable stakingToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    constructor(address _stakingToken) public {\n        stakingToken = IERC20(_stakingToken);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function stakeFor(address account, uint256 amount) internal {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        // we don't transferFrom here because this is only triggered\n        // when tokens have already been received\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract Rewards is\n    LPTokenWrapper,\n    IRewardDistributionRecipient,\n    ERC677Receiver\n{\n    IERC20 public immutable rewardToken;\n    uint256 public immutable duration;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        address _rewardToken,\n        address _stakingToken,\n        uint256 _duration\n    ) public LPTokenWrapper(_stakingToken) {\n        rewardToken = IERC20(_rewardToken);\n        duration = _duration;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function onTokenTransfer(\n        address sender,\n        uint256 amount,\n        bytes memory\n    ) public override updateReward(sender) {\n        require(msg.sender == address(stakingToken), \"!stakingToken\");\n        super.stakeFor(sender, amount);\n        emit Staked(sender, amount);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mocks/YearnVaultMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'hardhat/console.sol';\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport '../interfaces/IYearnController.sol';\nimport '../interfaces/IYearnVault.sol';\n\ncontract YearnVaultMock is ERC20 {\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    uint256 public min = 9500;\n    uint256 public constant max = 10000;\n\n    IYearnController public controller;\n    IDetailedERC20 public token;\n\n    constructor(IDetailedERC20 _token, IYearnController _controller)\n        public\n        ERC20('yEarn Mock', 'yMOCK')\n    {\n        token = _token;\n        controller = _controller;\n    }\n\n    function vdecimals() external view returns (uint8) {\n        return decimals();\n    }\n\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(controller.balanceOf(address(token)));\n    }\n\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    function deposit(uint256 _amount) external returns (uint256) {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 _shares = 0;\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, _shares);\n    }\n\n    function withdraw(uint256 _shares, address _recipient) external returns (uint256) {\n        uint256 _r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 _b = token.balanceOf(address(this));\n        if (_b < _r) {\n            uint256 _withdraw = _r.sub(_b);\n            controller.withdraw(address(token), _withdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(_b);\n            if (_diff < _withdraw) {\n                _r = _b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(_recipient, _r);\n    }\n\n    function pricePerShare() external view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    } // changed to v2\n\n    /// @dev This is not part of the vault contract and is meant for quick debugging contracts to have control over\n    /// completely clearing the vault buffer to test certain behaviors better.\n    function clear() external {\n        token.safeTransfer(address(controller), token.balanceOf(address(this)));\n        controller.earn(address(token), token.balanceOf(address(this)));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/IYearnController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\ninterface IYearnController {\n  function balanceOf(address _token) external view returns (uint256);\n  function earn(address _token, uint256 _amount) external;\n  function withdraw(address _token, uint256 _withdrawAmount) external;\n}"
    },
    "contracts/interfaces/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IDetailedERC20} from \"./IDetailedERC20.sol\";\n\ninterface IYearnVault  {\n    function balanceOf(address user)  external view returns (uint);\n    function pricePerShare()  external view returns (uint);\n    function deposit(uint amount)  external returns (uint);\n    function withdraw(uint shares, address recipient)  external returns (uint); \n    function token() external view returns (IDetailedERC20);\n    function totalAssets()  external view returns (uint);\n    function decimals() external  view returns (uint8);\n}"
    },
    "contracts/AlToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {IDetailedERC20} from \"./interfaces/IDetailedERC20.sol\";\n\n/// @title AlToken\n///\n/// @dev This is the contract for the Yaxis utillity token usd.\n///\n/// Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine tokens,\n/// transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After this is done,\n/// the deployer must revoke their admin role and minter role.\ncontract AlToken is AccessControl, ERC20(\"Yaxis USD\", \"yalUSD\") {\n    using SafeERC20 for ERC20;\n\n    /// @dev The identifier of the role which maintains other roles.\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n    /// @dev The identifier of the role which allows accounts to mint tokens.\n    bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n    /// @dev addresses whitelisted for minting new tokens\n    mapping(address => bool) public whiteList;\n\n    /// @dev addresses blacklisted for minting new tokens\n    mapping(address => bool) public blacklist;\n\n    /// @dev addresses paused for minting new tokens\n    mapping(address => bool) public paused;\n\n    /// @dev ceiling per address for minting new tokens\n    mapping(address => uint256) public ceiling;\n\n    /// @dev already minted amount per address to track the ceiling\n    mapping(address => uint256) public hasMinted;\n\n    event Paused(address alchemistAddress, bool isPaused);\n\n    constructor() public {\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(SENTINEL_ROLE, msg.sender);\n        _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    }\n\n    /// @dev A modifier which checks if whitelisted for minting.\n    modifier onlyWhitelisted() {\n        require(whiteList[msg.sender], \"AlUSD: Alchemist is not whitelisted\");\n        _;\n    }\n\n    /// @dev Mints tokens to a recipient.\n    ///\n    /// This function reverts if the caller does not have the minter role.\n    ///\n    /// @param _recipient the account to mint tokens to.\n    /// @param _amount    the amount of tokens to mint.\n    function mint(address _recipient, uint256 _amount)\n        external\n        onlyWhitelisted\n    {\n        require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n        require(!paused[msg.sender], \"AlUSD: user is currently paused.\");\n        uint256 _total = _amount.add(hasMinted[msg.sender]);\n        require(\n            _total <= ceiling[msg.sender],\n            \"AlUSD: Alchemist's ceiling was breached.\"\n        );\n        hasMinted[msg.sender] = _total;\n        _mint(_recipient, _amount);\n    }\n\n    /// This function reverts if the caller does not have the admin role.\n    ///\n    /// @param _toWhitelist the account to mint tokens to.\n    /// @param _state the whitelist state.\n\n    function setWhitelist(address _toWhitelist, bool _state)\n        external\n        onlyAdmin\n    {\n        whiteList[_toWhitelist] = _state;\n    }\n\n    /// This function reverts if the caller does not have the sentinel role.\n    ///\n    /// @param _toBlacklist the account to mint tokens to.\n    function setBlacklist(address _toBlacklist) external onlySentinel {\n        blacklist[_toBlacklist] = true;\n    }\n\n    /// This function reverts if the caller does not have the sentinel role.\n    function pauseAlchemist(address _toPause, bool _state)\n        external\n        onlySentinel\n    {\n        paused[_toPause] = _state;\n        emit Paused(_toPause, _state);\n    }\n\n    /// This function reverts if the caller does not have the admin role.\n    ///\n    /// @param _toSetCeiling the account set the ceiling off.\n    /// @param _ceiling the max amount of tokens the account is allowed to mint.\n    function setCeiling(address _toSetCeiling, uint256 _ceiling)\n        external\n        onlyAdmin\n    {\n        ceiling[_toSetCeiling] = _ceiling;\n    }\n\n    /// @dev A modifier which checks that the caller has the admin role.\n    modifier onlyAdmin() {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"only admin\");\n        _;\n    }\n    /// @dev A modifier which checks that the caller has the sentinel role.\n    modifier onlySentinel() {\n        require(hasRole(SENTINEL_ROLE, msg.sender), \"only sentinel\");\n        _;\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(\n            amount,\n            \"ERC20: burn amount exceeds allowance\"\n        );\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev lowers hasminted from the caller's allocation\n     *\n     */\n    function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n        hasMinted[msg.sender] = hasMinted[msg.sender].sub(amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/Transmuter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IERC20Burnable.sol\";\n\n//    ___    __        __                _               ___                              __         _\n//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \\  ____ ___   ___ ___   ___  / /_  ___  (_)\n//  / __ | / / / __/ / _ \\/ -_) /  ' \\ / /  \\ \\ /      / ___/ / __// -_) (_-</ -_) / _ \\/ __/ (_-< _\n// /_/ |_|/_/  \\__/ /_//_/\\__/ /_/_/_//_/  /_\\_\\      /_/    /_/   \\__/ /___/\\__/ /_//_/\\__/ /___/(_)\n//\n// .___________..______           ___      .__   __.      _______..___  ___.  __    __  .___________. _______ .______\n// |           ||   _  \\         /   \\     |  \\ |  |     /       ||   \\/   | |  |  |  | |           ||   ____||   _  \\\n// `---|  |----`|  |_)  |       /  ^  \\    |   \\|  |    |   (----`|  \\  /  | |  |  |  | `---|  |----`|  |__   |  |_)  |\n//     |  |     |      /       /  /_\\  \\   |  . `  |     \\   \\    |  |\\/|  | |  |  |  |     |  |     |   __|  |      /\n//     |  |     |  |\\  \\----. /  _____  \\  |  |\\   | .----)   |   |  |  |  | |  `--'  |     |  |     |  |____ |  |\\  \\----.\n//     |__|     | _| `._____|/__/     \\__\\ |__| \\__| |_______/    |__|  |__|  \\______/      |__|     |_______|| _| `._____|\n/**\n * @dev Implementation of the {IERC20Burnable} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20Burnable-approve}.\n */\ncontract Transmuter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20Burnable;\n    using Address for address;\n\n    address public constant ZERO_ADDRESS = address(0);\n\n    ///@dev values needed to calculate the distribution of base asset in proportion for alTokens staked\n    uint256 public constant POINT_MULTIPLIER = 10e18;\n\n    uint256 public transmutationPeriod;\n\n    address public immutable AlToken;\n    address public immutable Token;\n\n    mapping(address => uint256) public depositedAlTokens;\n    mapping(address => uint256) public tokensInBucket;\n    mapping(address => uint256) public realisedTokens;\n    mapping(address => uint256) public lastDividendPoints;\n\n    mapping(address => bool) public userIsKnown;\n    mapping(uint256 => address) public userList;\n    uint256 public nextUser;\n\n    uint256 public totalSupplyAltokens;\n    uint256 public buffer;\n    uint256 public lastDepositBlock;\n\n    uint256 public totalDividendPoints;\n    uint256 public unclaimedDividends;\n\n    /// @dev alchemist addresses whitelisted\n    mapping(address => bool) public whiteList;\n\n    /// @dev The address of the account which currently has administrative capabilities over this contract.\n    address public governance;\n\n    /// @dev The address of the pending governance.\n    address public pendingGovernance;\n\n    event GovernanceUpdated(address governance);\n\n    event PendingGovernanceUpdated(address pendingGovernance);\n\n    event TransmuterPeriodUpdated(uint256 newTransmutationPeriod);\n\n    constructor(\n        address _AlToken,\n        address _Token,\n        address _governance\n    ) public {\n        require(_governance != ZERO_ADDRESS, \"Transmuter: 0 gov\");\n        governance = _governance;\n        AlToken = _AlToken;\n        Token = _Token;\n        transmutationPeriod = 50;\n    }\n\n    ///@return displays the user's share of the pooled alTokens.\n    function dividendsOwing(address account) public view returns (uint256) {\n        uint256 newDividendPoints = totalDividendPoints.sub(\n            lastDividendPoints[account]\n        );\n        return\n            depositedAlTokens[account].mul(newDividendPoints).div(\n                POINT_MULTIPLIER\n            );\n    }\n\n    ///@dev modifier to fill the bucket and keep bookkeeping correct incase of increase/decrease in shares\n    modifier updateAccount(address account) {\n        uint256 owing = dividendsOwing(account);\n        if (owing > 0) {\n            unclaimedDividends = unclaimedDividends.sub(owing);\n            tokensInBucket[account] = tokensInBucket[account].add(owing);\n        }\n        lastDividendPoints[account] = totalDividendPoints;\n        _;\n    }\n    ///@dev modifier add users to userlist. Users are indexed in order to keep track of when a bond has been filled\n    modifier checkIfNewUser() {\n        if (!userIsKnown[msg.sender]) {\n            userList[nextUser] = msg.sender;\n            userIsKnown[msg.sender] = true;\n            nextUser++;\n        }\n        _;\n    }\n\n    ///@dev run the phased distribution of the buffered funds\n    modifier runPhasedDistribution() {\n        uint256 _lastDepositBlock = lastDepositBlock;\n        uint256 _currentBlock = block.number;\n        uint256 _toDistribute = 0;\n        uint256 _buffer = buffer;\n\n        // check if there is something in bufffer\n        if (_buffer > 0) {\n            // NOTE: if last deposit was updated in the same block as the current call\n            // then the below logic gates will fail\n\n            //calculate diffrence in time\n            uint256 deltaTime = _currentBlock.sub(_lastDepositBlock);\n\n            // distribute all if bigger than timeframe\n            if (deltaTime >= transmutationPeriod) {\n                _toDistribute = _buffer;\n            } else {\n                //needs to be bigger than 0 cuzz solidity no decimals\n                if (_buffer.mul(deltaTime) > transmutationPeriod) {\n                    _toDistribute = _buffer.mul(deltaTime).div(\n                        transmutationPeriod\n                    );\n                }\n            }\n\n            // factually allocate if any needs distribution\n            if (_toDistribute > 0) {\n                // remove from buffer\n                buffer = _buffer.sub(_toDistribute);\n\n                // increase the allocation\n                increaseAllocations(_toDistribute);\n            }\n        }\n\n        // current timeframe is now the last\n        lastDepositBlock = _currentBlock;\n        _;\n    }\n\n    /// @dev A modifier which checks if whitelisted for minting.\n    modifier onlyWhitelisted() {\n        require(whiteList[msg.sender], \"Transmuter: !whitelisted\");\n        _;\n    }\n\n    /// @dev Checks that the current message sender or caller is the governance address.\n    ///\n    ///\n    modifier onlyGov() {\n        require(msg.sender == governance, \"Transmuter: !governance\");\n        _;\n    }\n\n    ///@dev set the transmutationPeriod variable\n    ///\n    /// sets the length (in blocks) of one full distribution phase\n    function setTransmutationPeriod(uint256 newTransmutationPeriod)\n        public\n        onlyGov\n    {\n        transmutationPeriod = newTransmutationPeriod;\n        emit TransmuterPeriodUpdated(transmutationPeriod);\n    }\n\n    ///@dev claims the base token after it has been transmuted\n    ///\n    ///This function reverts if there is no realisedToken balance\n    function claim() public {\n        address sender = msg.sender;\n        require(realisedTokens[sender] > 0);\n        uint256 value = realisedTokens[sender];\n        realisedTokens[sender] = 0;\n        IERC20Burnable(Token).safeTransfer(sender, value);\n    }\n\n    ///@dev Withdraws staked alTokens from the transmuter\n    ///\n    /// This function reverts if you try to draw more tokens than you deposited\n    ///\n    ///@param amount the amount of alTokens to unstake\n    function unstake(uint256 amount)\n        public\n        runPhasedDistribution\n        updateAccount(msg.sender)\n    {\n        // by calling this function before transmuting you forfeit your gained allocation\n        address sender = msg.sender;\n        require(\n            depositedAlTokens[sender] >= amount,\n            \"Transmuter: unstake amount exceeds deposited amount\"\n        );\n        depositedAlTokens[sender] = depositedAlTokens[sender].sub(amount);\n        totalSupplyAltokens = totalSupplyAltokens.sub(amount);\n        IERC20Burnable(AlToken).safeTransfer(sender, amount);\n    }\n\n    ///@dev Deposits alTokens into the transmuter\n    ///\n    ///@param amount the amount of alTokens to stake\n    function stake(uint256 amount)\n        public\n        runPhasedDistribution\n        updateAccount(msg.sender)\n        checkIfNewUser\n    {\n        // requires approval of AlToken first\n        address sender = msg.sender;\n        //require tokens transferred in;\n        IERC20Burnable(AlToken).safeTransferFrom(sender, address(this), amount);\n        totalSupplyAltokens = totalSupplyAltokens.add(amount);\n        depositedAlTokens[sender] = depositedAlTokens[sender].add(amount);\n    }\n\n    /// @dev Converts the staked alTokens to the base tokens in amount of the sum of pendingdivs and tokensInBucket\n    ///\n    /// once the alToken has been converted, it is burned, and the base token becomes realisedTokens which can be recieved using claim()\n    ///\n    /// reverts if there are no pendingdivs or tokensInBucket\n    function transmute()\n        public\n        runPhasedDistribution\n        updateAccount(msg.sender)\n    {\n        address sender = msg.sender;\n        uint256 pendingz = tokensInBucket[sender];\n        uint256 diff;\n\n        require(pendingz > 0, \"need to have pending in bucket\");\n\n        tokensInBucket[sender] = 0;\n\n        // check bucket overflow\n        if (pendingz > depositedAlTokens[sender]) {\n            diff = pendingz.sub(depositedAlTokens[sender]);\n\n            // remove overflow\n            pendingz = depositedAlTokens[sender];\n        }\n\n        // decrease altokens\n        depositedAlTokens[sender] = depositedAlTokens[sender].sub(pendingz);\n\n        // BURN ALTOKENS\n        IERC20Burnable(AlToken).burn(pendingz);\n\n        // adjust total\n        totalSupplyAltokens = totalSupplyAltokens.sub(pendingz);\n\n        // reallocate overflow\n        increaseAllocations(diff);\n\n        // add payout\n        realisedTokens[sender] = realisedTokens[sender].add(pendingz);\n    }\n\n    /// @dev Executes transmute() on another account that has had more base tokens allocated to it than alTokens staked.\n    ///\n    /// The caller of this function will have the surlus base tokens credited to their tokensInBucket balance, rewarding them for performing this action\n    ///\n    /// This function reverts if the address to transmute is not over-filled.\n    ///\n    /// @param toTransmute address of the account you will force transmute.\n    function forceTransmute(address toTransmute)\n        public\n        runPhasedDistribution\n        updateAccount(msg.sender)\n        updateAccount(toTransmute)\n    {\n        //load into memory\n        address sender = msg.sender;\n        uint256 pendingz = tokensInBucket[toTransmute];\n        // check restrictions\n        require(\n            pendingz > depositedAlTokens[toTransmute],\n            \"Transmuter: !overflow\"\n        );\n\n        // empty bucket\n        tokensInBucket[toTransmute] = 0;\n\n        // calculaate diffrence\n        uint256 diff = pendingz.sub(depositedAlTokens[toTransmute]);\n\n        // remove overflow\n        pendingz = depositedAlTokens[toTransmute];\n\n        // decrease altokens\n        depositedAlTokens[toTransmute] = 0;\n\n        // BURN ALTOKENS\n        IERC20Burnable(AlToken).burn(pendingz);\n\n        // adjust total\n        totalSupplyAltokens = totalSupplyAltokens.sub(pendingz);\n\n        // reallocate overflow\n        tokensInBucket[sender] = tokensInBucket[sender].add(diff);\n\n        // add payout\n        realisedTokens[toTransmute] = realisedTokens[toTransmute].add(pendingz);\n\n        // force payout of realised tokens of the toTransmute address\n        if (realisedTokens[toTransmute] > 0) {\n            uint256 value = realisedTokens[toTransmute];\n            realisedTokens[toTransmute] = 0;\n            IERC20Burnable(Token).safeTransfer(toTransmute, value);\n        }\n    }\n\n    /// @dev Transmutes and unstakes all alTokens\n    ///\n    /// This function combines the transmute and unstake functions for ease of use\n    function exit() external {\n        transmute();\n        uint256 toWithdraw = depositedAlTokens[msg.sender];\n        unstake(toWithdraw);\n    }\n\n    /// @dev Transmutes and claims all converted base tokens.\n    ///\n    /// This function combines the transmute and claim functions while leaving your remaining alTokens staked.\n    function transmuteAndClaim() external {\n        transmute();\n        claim();\n    }\n\n    /// @dev Transmutes, claims base tokens, and withdraws alTokens.\n    ///\n    /// This function helps users to exit the transmuter contract completely after converting their alTokens to the base pair.\n    function transmuteClaimAndWithdraw() external {\n        transmute();\n        claim();\n        uint256 toWithdraw = depositedAlTokens[msg.sender];\n        unstake(toWithdraw);\n    }\n\n    /// @dev Distributes the base token proportionally to all alToken stakers.\n    ///\n    /// This function is meant to be called by the Alchemist contract for when it is sending yield to the transmuter.\n    /// Anyone can call this and add funds, idk why they would do that though...\n    ///\n    /// @param origin the account that is sending the tokens to be distributed.\n    /// @param amount the amount of base tokens to be distributed to the transmuter.\n    function distribute(address origin, uint256 amount)\n        public\n        onlyWhitelisted\n        runPhasedDistribution\n    {\n        IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);\n        buffer = buffer.add(amount);\n    }\n\n    /// @dev Allocates the incoming yield proportionally to all alToken stakers.\n    ///\n    /// @param amount the amount of base tokens to be distributed in the transmuter.\n    function increaseAllocations(uint256 amount) internal {\n        if (totalSupplyAltokens > 0 && amount > 0) {\n            totalDividendPoints = totalDividendPoints.add(\n                amount.mul(POINT_MULTIPLIER).div(totalSupplyAltokens)\n            );\n            unclaimedDividends = unclaimedDividends.add(amount);\n        } else {\n            buffer = buffer.add(amount);\n        }\n    }\n\n    /// @dev Gets the status of a user's staking position.\n    ///\n    /// The total amount allocated to a user is the sum of pendingdivs and inbucket.\n    ///\n    /// @param user the address of the user you wish to query.\n    ///\n    /// returns user status\n\n    function userInfo(address user)\n        public\n        view\n        returns (\n            uint256 depositedAl,\n            uint256 pendingdivs,\n            uint256 inbucket,\n            uint256 realised\n        )\n    {\n        uint256 _depositedAl = depositedAlTokens[user];\n        uint256 _toDistribute = buffer\n            .mul(block.number.sub(lastDepositBlock))\n            .div(transmutationPeriod);\n        if (block.number.sub(lastDepositBlock) > transmutationPeriod) {\n            _toDistribute = buffer;\n        }\n        uint256 _pendingdivs = _toDistribute.mul(depositedAlTokens[user]).div(\n            totalSupplyAltokens\n        );\n        uint256 _inbucket = tokensInBucket[user].add(dividendsOwing(user));\n        uint256 _realised = realisedTokens[user];\n        return (_depositedAl, _pendingdivs, _inbucket, _realised);\n    }\n\n    /// @dev Gets the status of multiple users in one call\n    ///\n    /// This function is used to query the contract to check for\n    /// accounts that have overfilled positions in order to check\n    /// who can be force transmuted.\n    ///\n    /// @param from the first index of the userList\n    /// @param to the last index of the userList\n    ///\n    /// returns the userList with their staking status in paginated form.\n    function getMultipleUserInfo(uint256 from, uint256 to)\n        public\n        view\n        returns (address[] memory theUserList, uint256[] memory theUserData)\n    {\n        uint256 i = from;\n        uint256 delta = to - from;\n        address[] memory _theUserList = new address[](delta); //user\n        uint256[] memory _theUserData = new uint256[](delta * 2); //deposited-bucket\n        uint256 y = 0;\n        uint256 _toDistribute = buffer\n            .mul(block.number.sub(lastDepositBlock))\n            .div(transmutationPeriod);\n        if (block.number.sub(lastDepositBlock) > transmutationPeriod) {\n            _toDistribute = buffer;\n        }\n        for (uint256 x = 0; x < delta; x += 1) {\n            _theUserList[x] = userList[i];\n            _theUserData[y] = depositedAlTokens[userList[i]];\n            _theUserData[y + 1] = dividendsOwing(userList[i])\n                .add(tokensInBucket[userList[i]])\n                .add(\n                    _toDistribute.mul(depositedAlTokens[userList[i]]).div(\n                        totalSupplyAltokens\n                    )\n                );\n            y += 2;\n            i += 1;\n        }\n        return (_theUserList, _theUserData);\n    }\n\n    /// @dev Gets info on the buffer\n    ///\n    /// This function is used to query the contract to get the\n    /// latest state of the buffer\n    ///\n    /// @return _toDistribute the amount ready to be distributed\n    /// @return _deltaBlocks the amount of time since the last phased distribution\n    /// @return _buffer the amount in the buffer\n    function bufferInfo()\n        public\n        view\n        returns (\n            uint256 _toDistribute,\n            uint256 _deltaBlocks,\n            uint256 _buffer\n        )\n    {\n        _deltaBlocks = block.number.sub(lastDepositBlock);\n        _buffer = buffer;\n        _toDistribute = _buffer.mul(_deltaBlocks).div(transmutationPeriod);\n    }\n\n    /// @dev Sets the pending governance.\n    ///\n    /// This function reverts if the new pending governance is the zero address or the caller is not the current\n    /// governance. This is to prevent the contract governance being set to the zero address which would deadlock\n    /// privileged contract functionality.\n    ///\n    /// @param _pendingGovernance the new pending governance.\n    function setPendingGovernance(address _pendingGovernance) external onlyGov {\n        require(_pendingGovernance != ZERO_ADDRESS, \"Transmuter: 0 gov\");\n\n        pendingGovernance = _pendingGovernance;\n\n        emit PendingGovernanceUpdated(_pendingGovernance);\n    }\n\n    /// @dev Accepts the role as governance.\n    ///\n    /// This function reverts if the caller is not the new pending governance.\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"!pendingGovernance\");\n        address _pendingGovernance = pendingGovernance;\n        governance = _pendingGovernance;\n\n        emit GovernanceUpdated(_pendingGovernance);\n    }\n\n    /// This function reverts if the caller is not governance\n    ///\n    /// @param _toWhitelist the account to mint tokens to.\n    /// @param _state the whitelist state.\n\n    function setWhitelist(address _toWhitelist, bool _state) external onlyGov {\n        whiteList[_toWhitelist] = _state;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Burnable is IERC20 {\n  function burn(uint256 amount) external;\n  function burnFrom(address account, uint256 amount) external;\n}"
    },
    "contracts/mocks/YearnControllerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'hardhat/console.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYearnController.sol';\n\ncontract YearnControllerMock is IYearnController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public constant blackhole = 0x000000000000000000000000000000000000dEaD;\n\n    uint256 public withdrawalFee = 50;\n    uint256 public constant withdrawalMax = 10000;\n\n    function setWithdrawalFee(uint256 _withdrawalFee) external {\n        withdrawalFee = _withdrawalFee;\n    }\n\n    function balanceOf(address _token) external view override returns (uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function earn(address _token, uint256 _amount) external override {}\n\n    function withdraw(address _token, uint256 _amount) external override {\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        // uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);\n\n        // IERC20(_token).safeTransfer(blackhole, _fee);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n}\n"
    },
    "contracts/mocks/YaxisVaultMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract YaxisVaultMock is ERC20 {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    ERC20 public token;\n\n    address public gauge;\n\n    constructor(ERC20 _token) public ERC20(\"yEarn Mock\", \"yMOCK\") {\n        token = _token;\n    }\n\n    function setGauge(address _gauge) external {\n        gauge = _gauge;\n    }\n\n    function deposit(uint256 _amount) external returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _shares) external {\n        _burn(msg.sender, _shares);\n        token.safeTransfer(msg.sender, _shares);\n    }\n\n    function getPricePerFullShare() external view returns (uint256) {\n        return 1e18;\n    }\n\n    function getToken() external view returns (address) {\n        return address(token);\n    }\n\n    function getLPToken() external view returns (address) {\n        return address(this);\n    }\n}\n"
    },
    "contracts/mocks/GaugeMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract GaugeMock is ERC20 {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    ERC20 public token;\n    mapping(address => uint256) public balances;\n\n    address public gauge;\n\n    constructor(ERC20 _token) public ERC20(\"gauce Mock\", \"gMOCK\") {\n        token = _token;\n    }\n\n    function deposit(uint256 _amount) external {\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        balances[msg.sender] += _amount;\n    }\n\n    function withdraw(uint256 _amount) external {\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        token.safeTransfer(msg.sender, _amount);\n    }\n\n    function claim_rewards() external {\n        _mint(msg.sender, 1e18);\n    }\n\n    function reward_tokens(uint256) external view returns (address) {\n        return address(this);\n    }\n}\n"
    },
    "contracts/adapters/YearnVaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'hardhat/console.sol';\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport {IDetailedERC20} from '../interfaces/IDetailedERC20.sol';\nimport {IVaultAdapter} from '../interfaces/IVaultAdapter.sol';\nimport {IyVaultV2} from '../interfaces/IyVaultV2.sol';\n\n/// @title YearnVaultAdapter\n///\n/// @dev A vault adapter implementation which wraps a yEarn vault.\ncontract YearnVaultAdapter is IVaultAdapter {\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    /// @dev The vault that the adapter is wrapping.\n    IyVaultV2 public vault;\n\n    /// @dev The address which has admin control over this contract.\n    address public admin;\n\n    /// @dev The decimals of the token.\n    uint256 public decimals;\n\n    constructor(IyVaultV2 _vault, address _admin) public {\n        vault = _vault;\n        admin = _admin;\n        updateApproval();\n        decimals = _vault.decimals();\n    }\n\n    /// @dev A modifier which reverts if the caller is not the admin.\n    modifier onlyAdmin() {\n        require(admin == msg.sender, 'YearnVaultAdapter: only admin');\n        _;\n    }\n\n    /// @dev Gets the token that the vault accepts.\n    ///\n    /// @return the accepted token.\n    function token() external view override returns (IDetailedERC20) {\n        return IDetailedERC20(vault.token());\n    }\n\n    /// @dev Gets the total value of the assets that the adapter holds in the vault.\n    ///\n    /// @return the total assets.\n    function totalValue() external view override returns (uint256) {\n        return _sharesToTokens(vault.balanceOf(address(this)));\n    }\n\n    /// @dev Deposits tokens into the vault.\n    ///\n    /// @param _amount the amount of tokens to deposit into the vault.\n    function deposit(uint256 _amount) external override {\n        vault.deposit(_amount);\n    }\n\n    /// @dev Withdraws tokens from the vault to the recipient.\n    ///\n    /// This function reverts if the caller is not the admin.\n    ///\n    /// @param _recipient the account to withdraw the tokes to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {\n        vault.withdraw(_tokensToShares(_amount), _recipient);\n    }\n\n    /// @dev Updates the vaults approval of the token to be the maximum value.\n    function updateApproval() public {\n        address _token = vault.token();\n        IDetailedERC20(_token).safeApprove(address(vault), uint256(-1));\n    }\n\n    /// @dev Computes the number of tokens an amount of shares is worth.\n    ///\n    /// @param _sharesAmount the amount of shares.\n    ///\n    /// @return the number of tokens the shares are worth.\n\n    function _sharesToTokens(uint256 _sharesAmount) internal view returns (uint256) {\n        return _sharesAmount.mul(vault.pricePerShare()).div(10**decimals);\n    }\n\n    /// @dev Computes the number of shares an amount of tokens is worth.\n    ///\n    /// @param _tokensAmount the amount of shares.\n    ///\n    /// @return the number of shares the tokens are worth.\n    function _tokensToShares(uint256 _tokensAmount) internal view returns (uint256) {\n        return _tokensAmount.mul(10**decimals).div(vault.pricePerShare());\n    }\n}\n"
    },
    "contracts/interfaces/IyVaultV2.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IyVaultV2 is IERC20 {\n    function token() external view returns (address);\n    function deposit() external returns (uint);\n    function deposit(uint) external returns (uint);\n    function deposit(uint, address) external returns (uint);\n    function withdraw() external returns (uint);\n    function withdraw(uint) external returns (uint);\n    function withdraw(uint, address) external returns (uint);\n    function withdraw(uint, address, uint) external returns (uint);\n    function permit(address, address, uint, uint, bytes32) external view returns (bool);\n    function pricePerShare() external view returns (uint);\n    \n    function apiVersion() external view returns (string memory);\n    function totalAssets() external view returns (uint);\n    function maxAvailableShares() external view returns (uint);\n    function debtOutstanding() external view returns (uint);\n    function debtOutstanding(address strategy) external view returns (uint);\n    function creditAvailable() external view returns (uint);\n    function creditAvailable(address strategy) external view returns (uint);\n    function availableDepositLimit() external view returns (uint);\n    function expectedReturn() external view returns (uint);\n    function expectedReturn(address strategy) external view returns (uint);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint);\n    function balanceOf(address owner) external view override returns (uint);\n    function totalSupply() external view override returns (uint);\n    function governance() external view returns (address);\n    function management() external view returns (address);\n    function guardian() external view returns (address);\n    function guestList() external view returns (address);\n    function strategies(address) external view returns (uint, uint, uint, uint, uint, uint, uint, uint);\n    function withdrawalQueue(uint) external view returns (address);\n    function emergencyShutdown() external view returns (bool);\n    function depositLimit() external view returns (uint);\n    function debtRatio() external view returns (uint);\n    function totalDebt() external view returns (uint);\n    function lastReport() external view returns (uint);\n    function activation() external view returns (uint);\n    function rewards() external view returns (address);\n    function managementFee() external view returns (uint);\n    function performanceFee() external view returns (uint);\n}"
    },
    "contracts/ConvertAlchemist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n//import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {CDP} from \"./libraries/alchemist/CDP.sol\";\nimport {FixedPointMath} from \"./libraries/FixedPointMath.sol\";\nimport {AlchemistVault} from \"./libraries/alchemist/AlchemistVault.sol\";\nimport {ITransmuter} from \"./interfaces/ITransmuter.sol\";\nimport {IMintableERC20} from \"./interfaces/IMintableERC20.sol\";\nimport {ICurveToken} from \"./interfaces/ICurveToken.sol\";\nimport {IVaultAdapter} from \"./interfaces/IVaultAdapter.sol\";\n\n// ERC20,removing ERC20 from the alchemist\n//    ___    __        __                _               ___                              __         _\n//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \\  ____ ___   ___ ___   ___  / /_  ___  (_)\n//  / __ | / / / __/ / _ \\/ -_) /  ' \\ / /  \\ \\ /      / ___/ / __// -_) (_-</ -_) / _ \\/ __/ (_-< _\n// /_/ |_|/_/  \\__/ /_//_/\\__/ /_/_/_//_/  /_\\_\\      /_/    /_/   \\__/ /___/\\__/ /_//_/\\__/ /___/(_)\n//\n//      ___       __        ______  __    __   _______ .___  ___.  __       _______..___________.\n//     /   \\     |  |      /      ||  |  |  | |   ____||   \\/   | |  |     /       ||           |\n//    /  ^  \\    |  |     |  ,----'|  |__|  | |  |__   |  \\  /  | |  |    |   (----``---|  |----`\n//   /  /_\\  \\   |  |     |  |     |   __   | |   __|  |  |\\/|  | |  |     \\   \\        |  |\n//  /  _____  \\  |  `----.|  `----.|  |  |  | |  |____ |  |  |  | |  | .----)   |       |  |\n// /__/     \\__\\ |_______| \\______||__|  |__| |_______||__|  |__| |__| |_______/        |__|\n\ncontract ConvertAlchemist is ReentrancyGuard {\n    using CDP for CDP.Data;\n    using FixedPointMath for FixedPointMath.FixedDecimal;\n    using AlchemistVault for AlchemistVault.Data;\n    using AlchemistVault for AlchemistVault.List;\n    using SafeERC20 for IMintableERC20;\n    using SafeMath for uint256;\n    using Address for address;\n\n    address public constant ZERO_ADDRESS = address(0);\n\n    /// @dev Resolution for all fixed point numeric parameters which represent percents. The resolution allows for a\n    /// granularity of 0.01% increments.\n    uint256 public constant PERCENT_RESOLUTION = 10000;\n\n    /// @dev The minimum value that the collateralization limit can be set to by the governance. This is a safety rail\n    /// to prevent the collateralization from being set to a value which breaks the system.\n    ///\n    /// This value is equal to 100%.\n    ///\n    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the\n    ///            resolution for the FixedPointMath library changes this constant must change as well.\n    uint256 public constant MINIMUM_COLLATERALIZATION_LIMIT =\n        1000000000000000000;\n\n    /// @dev The maximum value that the collateralization limit can be set to by the governance. This is a safety rail\n    /// to prevent the collateralization from being set to a value which breaks the system.\n    ///\n    /// This value is equal to 400%.\n    ///\n    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the\n    ///            resolution for the FixedPointMath library changes this constant must change as well.\n    uint256 public constant MAXIMUM_COLLATERALIZATION_LIMIT =\n        4000000000000000000;\n\n    event GovernanceUpdated(address governance);\n\n    event PendingGovernanceUpdated(address pendingGovernance);\n\n    event SentinelUpdated(address sentinel);\n\n    event TransmuterUpdated(address transmuter);\n\n    event RewardsUpdated(address treasury);\n\n    event HarvestFeeUpdated(uint256 fee);\n\n    event BorrowFeeUpdated(uint256 fee);\n\n    event CollateralizationLimitUpdated(uint256 limit);\n\n    event PegMinimumUpdated(uint256 pegMinimum);\n\n    event EmergencyExitUpdated(bool status);\n\n    event ActiveVaultUpdated(IVaultAdapter indexed adapter);\n\n    event FundsHarvested(uint256 withdrawnAmount, uint256 decreasedValue);\n\n    event FundsRecalled(\n        uint256 indexed vaultId,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    event FundsFlushed(uint256 amount);\n\n    event TokensDeposited(address indexed account, uint256 amount);\n\n    event TokensWithdrawn(\n        address indexed account,\n        uint256 requestedAmount,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    event TokensRepaid(\n        address indexed account,\n        uint256 parentAmount,\n        uint256 childAmount\n    );\n\n    event TokensLiquidated(\n        address indexed account,\n        uint256 requestedAmount,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    /// @dev The token that this contract is using as the source of parent asset.\n    IMintableERC20 public sourceToken;\n\n    int128 public sourceIndex;\n\n    /// @dev The token that this contract is using as the parent asset.\n    IMintableERC20 public token;\n\n    /// @dev The token that this contract is using as the child asset.\n    IMintableERC20 public xtoken;\n\n    /// @dev The address of the account which currently has administrative capabilities over this contract.\n    address public governance;\n\n    /// @dev The address of the pending governance.\n    address public pendingGovernance;\n\n    /// @dev The address of the account which can initiate an emergency withdraw of funds in a vault.\n    address public sentinel;\n\n    /// @dev The address of the contract which will transmute synthetic tokens back into native tokens.\n    address public transmuter;\n\n    /// @dev The address of the contract which will receive fees.\n    address public rewards;\n\n    /// @dev The percent of each profitable harvest that will go to the rewards contract.\n    uint256 public harvestFee;\n\n    /// @dev The percent of minted debt that will go to the rewards contract.\n    uint256 public borrowFee;\n\n    /// @dev The total amount the native token deposited into the system that is owned by external users.\n    uint256 public totalDeposited;\n\n    /// @dev when movemetns are bigger than this number flush is activated.\n    uint256 public flushActivator;\n\n    /// @dev A flag indicating if the contract has been initialized yet.\n    bool public initialized;\n\n    /// @dev A flag indicating if deposits and flushes should be halted and if all parties should be able to recall\n    /// from the active vault.\n    bool public emergencyExit;\n\n    /// @dev The context shared between the CDPs.\n    CDP.Context private _ctx;\n\n    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either\n    /// create a new address.\n    mapping(address => CDP.Data) private _cdps;\n\n    /// @dev A list of all of the vaults. The last element of the list is the vault that is currently being used for\n    /// deposits and withdraws. Vaults before the last element are considered inactive and are expected to be cleared.\n    AlchemistVault.List private _vaults;\n\n    /// @dev The minimum returned amount needed to be on peg according to the oracle.\n    uint256 public pegMinimum;\n\n    constructor(\n        IMintableERC20 _sourceToken,\n        int128 _sourceIndex,\n        IMintableERC20 _token,\n        IMintableERC20 _xtoken,\n        address _governance,\n        address _sentinel\n    )\n        public\n    /*ERC20(\n      string(abi.encodePacked(\"Alchemic \", _token.name())),\n      string(abi.encodePacked(\"al\", _token.symbol()))\n    )*/\n    {\n        require(\n            _governance != ZERO_ADDRESS,\n            \"Alchemist: governance address cannot be 0x0.\"\n        );\n        require(\n            _sentinel != ZERO_ADDRESS,\n            \"Alchemist: sentinel address cannot be 0x0.\"\n        );\n\n        sourceToken = _sourceToken;\n        sourceIndex = _sourceIndex;\n        token = _token;\n        xtoken = _xtoken;\n        governance = _governance;\n        sentinel = _sentinel;\n        flushActivator = 100000 ether; // change for non 18 digit tokens\n\n        //_setupDecimals(_token.decimals());\n        uint256 COLL_LIMIT = MINIMUM_COLLATERALIZATION_LIMIT.mul(2);\n        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(COLL_LIMIT);\n        _ctx.accumulatedYieldWeight = FixedPointMath.FixedDecimal(0);\n    }\n\n    /// @dev Sets the pending governance.\n    ///\n    /// This function reverts if the new pending governance is the zero address or the caller is not the current\n    /// governance. This is to prevent the contract governance being set to the zero address which would deadlock\n    /// privileged contract functionality.\n    ///\n    /// @param _pendingGovernance the new pending governance.\n    function setPendingGovernance(address _pendingGovernance) external onlyGov {\n        require(\n            _pendingGovernance != ZERO_ADDRESS,\n            \"Alchemist: governance address cannot be 0x0.\"\n        );\n\n        pendingGovernance = _pendingGovernance;\n\n        emit PendingGovernanceUpdated(_pendingGovernance);\n    }\n\n    /// @dev Accepts the role as governance.\n    ///\n    /// This function reverts if the caller is not the new pending governance.\n    function acceptGovernance() external {\n        address _pendingGovernance = pendingGovernance;\n        require(\n            msg.sender == _pendingGovernance,\n            \"sender is not pendingGovernance\"\n        );\n        governance = _pendingGovernance;\n\n        emit GovernanceUpdated(_pendingGovernance);\n    }\n\n    function setSentinel(address _sentinel) external onlyGov {\n        require(\n            _sentinel != ZERO_ADDRESS,\n            \"Alchemist: sentinel address cannot be 0x0.\"\n        );\n\n        sentinel = _sentinel;\n\n        emit SentinelUpdated(_sentinel);\n    }\n\n    /// @dev Sets the transmuter.\n    ///\n    /// This function reverts if the new transmuter is the zero address or the caller is not the current governance.\n    ///\n    /// @param _transmuter the new transmuter.\n    function setTransmuter(address _transmuter) external onlyGov {\n        // Check that the transmuter address is not the zero address. Setting the transmuter to the zero address would break\n        // transfers to the address because of `safeTransfer` checks.\n        require(\n            _transmuter != ZERO_ADDRESS,\n            \"Alchemist: transmuter address cannot be 0x0.\"\n        );\n\n        transmuter = _transmuter;\n\n        emit TransmuterUpdated(_transmuter);\n    }\n\n    /// @dev Sets the flushActivator.\n    ///\n    /// @param _flushActivator the new flushActivator.\n    function setFlushActivator(uint256 _flushActivator) external onlyGov {\n        flushActivator = _flushActivator;\n    }\n\n    /// @dev Sets the rewards contract.\n    ///\n    /// This function reverts if the new rewards contract is the zero address or the caller is not the current governance.\n    ///\n    /// @param _rewards the new rewards contract.\n    function setRewards(address _rewards) external onlyGov {\n        // Check that the rewards address is not the zero address. Setting the rewards to the zero address would break\n        // transfers to the address because of `safeTransfer` checks.\n        require(\n            _rewards != ZERO_ADDRESS,\n            \"Alchemist: rewards address cannot be 0x0.\"\n        );\n\n        rewards = _rewards;\n\n        emit RewardsUpdated(_rewards);\n    }\n\n    /// @dev Sets the harvest fee.\n    ///\n    /// This function reverts if the caller is not the current governance.\n    ///\n    /// @param _harvestFee the new harvest fee.\n    function setHarvestFee(uint256 _harvestFee) external onlyGov {\n        // Check that the harvest fee is within the acceptable range. Setting the harvest fee greater than 100% could\n        // potentially break internal logic when calculating the harvest fee.\n        require(\n            _harvestFee <= PERCENT_RESOLUTION,\n            \"Alchemist: harvest fee above maximum.\"\n        );\n\n        harvestFee = _harvestFee;\n\n        emit HarvestFeeUpdated(_harvestFee);\n    }\n\n    /// @dev Sets the borrow fee.\n    ///\n    /// This function reverts if the caller is not the current governance.\n    ///\n    /// @param _borrowFee the new borrow fee.\n    function setBorrowFee(uint256 _borrowFee) external onlyGov {\n        // Check that the borrow fee is within the acceptable range. Setting the borrow fee greater than 100% could\n        // potentially break internal logic when calculating the borrow fee.\n        require(\n            _borrowFee <= PERCENT_RESOLUTION,\n            \"Alchemist: borrow fee above maximum.\"\n        );\n\n        borrowFee = _borrowFee;\n\n        emit BorrowFeeUpdated(_borrowFee);\n    }\n\n    /// @dev Sets the collateralization limit.\n    ///\n    /// This function reverts if the caller is not the current governance or if the collateralization limit is outside\n    /// of the accepted bounds.\n    ///\n    /// @param _limit the new collateralization limit.\n    function setCollateralizationLimit(uint256 _limit) external onlyGov {\n        require(\n            _limit >= MINIMUM_COLLATERALIZATION_LIMIT,\n            \"Alchemist: collateralization limit below minimum.\"\n        );\n        require(\n            _limit <= MAXIMUM_COLLATERALIZATION_LIMIT,\n            \"Alchemist: collateralization limit above maximum.\"\n        );\n\n        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(_limit);\n\n        emit CollateralizationLimitUpdated(_limit);\n    }\n\n    /// @dev Set pegMinimum.\n    function setPegMinimum(uint256 peg) external onlyGov {\n        pegMinimum = peg;\n        emit PegMinimumUpdated(pegMinimum);\n    }\n\n    /// @dev Sets if the contract should enter emergency exit mode.\n    ///\n    /// @param _emergencyExit if the contract should enter emergency exit mode.\n    function setEmergencyExit(bool _emergencyExit) external {\n        require(msg.sender == governance || msg.sender == sentinel, \"\");\n\n        emergencyExit = _emergencyExit;\n\n        emit EmergencyExitUpdated(_emergencyExit);\n    }\n\n    /// @dev Gets the collateralization limit.\n    ///\n    /// The collateralization limit is the minimum ratio of collateral to debt that is allowed by the system.\n    ///\n    /// @return the collateralization limit.\n    function collateralizationLimit()\n        external\n        view\n        returns (FixedPointMath.FixedDecimal memory)\n    {\n        return _ctx.collateralizationLimit;\n    }\n\n    /// @dev Initializes the contract.\n    ///\n    /// This function checks that the transmuter and rewards have been set and sets up the active vault.\n    ///\n    /// @param _adapter the vault adapter of the active vault.\n    function initialize(IVaultAdapter _adapter) external onlyGov {\n        require(!initialized, \"Alchemist: already initialized\");\n\n        require(\n            transmuter != ZERO_ADDRESS,\n            \"Alchemist: cannot initialize transmuter address to 0x0\"\n        );\n        require(\n            rewards != ZERO_ADDRESS,\n            \"Alchemist: cannot initialize rewards address to 0x0\"\n        );\n\n        _updateActiveVault(_adapter);\n\n        initialized = true;\n    }\n\n    /// @dev Migrates the system to a new vault.\n    ///\n    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\n    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\n    ///\n    /// @param _adapter the adapter for the vault the system will migrate to.\n    function migrate(IVaultAdapter _adapter)\n        external\n        expectInitialized\n        onlyGov\n    {\n        _updateActiveVault(_adapter);\n    }\n\n    /// @dev Harvests yield from a vault.\n    ///\n    /// @param _vaultId the identifier of the vault to harvest from.\n    ///\n    /// @return the amount of funds that were harvested from the vault.\n    function harvest(uint256 _vaultId)\n        external\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n\n        (uint256 _harvestedAmount, uint256 _decreasedValue) = _vault.harvest(\n            address(this)\n        );\n\n        if (_harvestedAmount > 0) {\n            uint256 _feeAmount = _harvestedAmount.mul(harvestFee).div(\n                PERCENT_RESOLUTION\n            );\n            uint256 _distributeAmount = _harvestedAmount.sub(_feeAmount);\n\n            FixedPointMath.FixedDecimal memory _weight = FixedPointMath\n                .fromU256(_distributeAmount)\n                .div(totalDeposited);\n            _ctx.accumulatedYieldWeight = _ctx.accumulatedYieldWeight.add(\n                _weight\n            );\n\n            if (_feeAmount > 0) {\n                token.safeTransfer(rewards, _feeAmount);\n            }\n\n            if (_distributeAmount > 0) {\n                _distributeToTransmuter(_distributeAmount);\n\n                // token.safeTransfer(transmuter, _distributeAmount); previous version call\n            }\n        }\n\n        emit FundsHarvested(_harvestedAmount, _decreasedValue);\n\n        return (_harvestedAmount, _decreasedValue);\n    }\n\n    /// @dev Recalls an amount of deposited funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function recall(uint256 _vaultId, uint256 _amount)\n        external\n        nonReentrant\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        return _recallFunds(_vaultId, _amount);\n    }\n\n    /// @dev Recalls all the deposited funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function recallAll(uint256 _vaultId)\n        external\n        nonReentrant\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _recallFunds(_vaultId, _vault.totalDeposited);\n    }\n\n    /// @dev Flushes buffered tokens to the active vault.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @return the amount of tokens flushed to the active vault.\n    function flush()\n        external\n        nonReentrant\n        notEmergency\n        expectInitialized\n        returns (uint256)\n    {\n        // Prevent flushing to the active vault when an emergency exit is enabled to prevent potential loss of funds if\n        // the active vault is poisoned for any reason.\n        return flushActiveVault();\n    }\n\n    /// @dev Internal function to flush buffered tokens to the active vault.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @return the amount of tokens flushed to the active vault.\n    function flushActiveVault() internal returns (uint256) {\n        AlchemistVault.Data storage _activeVault = _vaults.last();\n        uint256 _depositedAmount = _activeVault.depositAll();\n\n        emit FundsFlushed(_depositedAmount);\n\n        return _depositedAmount;\n    }\n\n    /// @dev Deposits collateral into a CDP.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @param _amount the amount of collateral to deposit.\n    function deposit(uint256 _amount)\n        external\n        nonReentrant\n        notEmergency\n        noContractAllowed\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        sourceToken.safeTransferFrom(msg.sender, address(this), _amount);\n        sourceToken.approve(address(token), _amount);\n\n        uint256[2] memory tokenAmounts;\n        tokenAmounts[uint256(sourceIndex)] = _amount;\n        uint256 mintedAmount = ICurveToken(address(token)).add_liquidity(\n            tokenAmounts,\n            0\n        );\n\n        if (mintedAmount >= flushActivator) {\n            flushActiveVault();\n        }\n        totalDeposited = totalDeposited.add(mintedAmount);\n\n        _cdp.totalDeposited = _cdp.totalDeposited.add(mintedAmount);\n        _cdp.lastDeposit = block.number;\n\n        emit TokensDeposited(msg.sender, mintedAmount);\n    }\n\n    /// @dev Attempts to withdraw part of a CDP's collateral.\n    ///\n    /// This function reverts if a deposit into the CDP was made in the same block. This is to prevent flash loan attacks\n    /// on other internal or external systems.\n    ///\n    /// @param _amount the amount of collateral to withdraw.\n    function withdraw(uint256 _amount)\n        external\n        nonReentrant\n        noContractAllowed\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        require(block.number > _cdp.lastDeposit, \"\");\n\n        _cdp.update(_ctx);\n\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(\n            msg.sender,\n            _amount\n        );\n\n        _cdp.totalDeposited = _cdp.totalDeposited.sub(\n            _decreasedValue,\n            \"Exceeds withdrawable amount\"\n        );\n        _cdp.checkHealth(\n            _ctx,\n            \"Action blocked: unhealthy collateralization ratio\"\n        );\n        if (_amount >= flushActivator) {\n            flushActiveVault();\n        }\n        emit TokensWithdrawn(\n            msg.sender,\n            _amount,\n            _withdrawnAmount,\n            _decreasedValue\n        );\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Repays debt with the native and or synthetic token.\n    ///\n    /// An approval is required to transfer native tokens to the transmuter.\n    function repay(uint256 _parentAmount, uint256 _childAmount)\n        external\n        nonReentrant\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        uint256 distributedAmount;\n\n        if (_parentAmount > 0) {\n            sourceToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                _parentAmount\n            );\n            sourceToken.approve(address(token), _parentAmount);\n\n            uint256[2] memory tokenAmounts;\n            tokenAmounts[uint256(sourceIndex)] = _parentAmount;\n            distributedAmount = ICurveToken(address(token)).add_liquidity(\n                tokenAmounts,\n                0\n            );\n\n            _distributeToTransmuter(distributedAmount);\n        }\n\n        if (_childAmount > 0) {\n            xtoken.burnFrom(msg.sender, _childAmount);\n            //lower debt cause burn\n            xtoken.lowerHasMinted(_childAmount);\n        }\n\n        uint256 _totalAmount = distributedAmount.add(_childAmount);\n        _cdp.totalDebt = _cdp.totalDebt.sub(_totalAmount, \"\");\n\n        emit TokensRepaid(msg.sender, distributedAmount, _childAmount);\n    }\n\n    /// @dev Attempts to liquidate part of a CDP's collateral to pay back its debt.\n    ///\n    /// @param _amount the amount of collateral to attempt to liquidate.\n    function liquidate(uint256 _amount)\n        external\n        nonReentrant\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        // don't attempt to liquidate more than is possible\n        if (_amount > _cdp.totalDebt) {\n            _amount = _cdp.totalDebt;\n        }\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(\n            address(this),\n            _amount\n        );\n        //changed to new transmuter compatibillity\n        _distributeToTransmuter(_withdrawnAmount);\n\n        _cdp.totalDeposited = _cdp.totalDeposited.sub(_decreasedValue, \"\");\n        _cdp.totalDebt = _cdp.totalDebt.sub(_withdrawnAmount, \"\");\n        emit TokensLiquidated(\n            msg.sender,\n            _amount,\n            _withdrawnAmount,\n            _decreasedValue\n        );\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Mints synthetic tokens by either claiming credit or increasing the debt.\n    ///\n    /// Claiming credit will take priority over increasing the debt.\n    ///\n    /// This function reverts if the debt is increased and the CDP health check fails.\n    ///\n    /// @param _amount the amount of alchemic tokens to borrow.\n    function mint(uint256 _amount)\n        external\n        nonReentrant\n        notEmergency\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        uint256 _totalCredit = _cdp.totalCredit;\n\n        if (_totalCredit < _amount) {\n            uint256 _remainingAmount = _amount - _totalCredit;\n\n            if (borrowFee > 0) {\n                uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(\n                    PERCENT_RESOLUTION\n                );\n                _remainingAmount = _remainingAmount.add(_borrowFeeAmount);\n                xtoken.mint(rewards, _borrowFeeAmount);\n            }\n            _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);\n            _cdp.totalCredit = 0;\n\n            _cdp.checkHealth(_ctx, \"Alchemist: Loan-to-value ratio breached\");\n        } else {\n            _cdp.totalCredit = _totalCredit.sub(_amount);\n        }\n\n        xtoken.mint(msg.sender, _amount);\n        if (_amount >= flushActivator) {\n            flushActiveVault();\n        }\n    }\n\n    /// @dev Gets the number of vaults in the vault list.\n    ///\n    /// @return the vault count.\n    function vaultCount() external view returns (uint256) {\n        return _vaults.length();\n    }\n\n    /// @dev Get the adapter of a vault.\n    ///\n    /// @param _vaultId the identifier of the vault.\n    ///\n    /// @return the vault adapter.\n    function getVaultAdapter(uint256 _vaultId)\n        external\n        view\n        returns (IVaultAdapter)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _vault.adapter;\n    }\n\n    /// @dev Get the total amount of the parent asset that has been deposited into a vault.\n    ///\n    /// @param _vaultId the identifier of the vault.\n    ///\n    /// @return the total amount of deposited tokens.\n    function getVaultTotalDeposited(uint256 _vaultId)\n        external\n        view\n        returns (uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _vault.totalDeposited;\n    }\n\n    /// @dev Get the total amount of collateral deposited into a CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the deposited amount of tokens.\n    function getCdpTotalDeposited(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.totalDeposited;\n    }\n\n    /// @dev Get the total amount of alchemic tokens borrowed from a CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the borrowed amount of tokens.\n    function getCdpTotalDebt(address _account) external view returns (uint256) {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.getUpdatedTotalDebt(_ctx);\n    }\n\n    /// @dev Get the total amount of credit that a CDP has.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the amount of credit.\n    function getCdpTotalCredit(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.getUpdatedTotalCredit(_ctx);\n    }\n\n    /// @dev Gets the last recorded block of when a user made a deposit into their CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the block number of the last deposit.\n    function getCdpLastDeposit(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.lastDeposit;\n    }\n\n    /// @dev sends tokens to the transmuter\n    ///\n    /// benefit of great nation of transmuter\n    function _distributeToTransmuter(uint256 amount) internal {\n        token.approve(transmuter, amount);\n        ITransmuter(transmuter).distribute(address(this), amount);\n        // lower debt cause of 'burn'\n        xtoken.lowerHasMinted(amount);\n    }\n\n    /// @dev Checks that parent token is on peg.\n    ///\n    /// This is used over a modifier limit of pegged interactions.\n    modifier onPriceCheck() {\n        if (pegMinimum > 0) {\n            require(\n                ICurveToken(address(token)).get_virtual_price() > pegMinimum,\n                \"off peg limitation\"\n            );\n        }\n        _;\n    }\n    /// @dev Checks that caller is not a contract.\n    ///\n    /// This is used to prevent contracts from interacting.\n    modifier noContractAllowed() {\n        require(\n            !address(msg.sender).isContract() && msg.sender == tx.origin,\n            \"Sorry we do not accept contract!\"\n        );\n        _;\n    }\n    /// @dev Checks that the contract is in an initialized state.\n    ///\n    /// This is used over a modifier to reduce the size of the contract\n    modifier expectInitialized() {\n        require(initialized, \"Alchemist: not initialized.\");\n        _;\n    }\n\n    /// @dev Checks that the current message sender or caller is the governance address.\n    ///\n    ///\n    modifier onlyGov() {\n        require(msg.sender == governance, \"Alchemist: only governance.\");\n        _;\n    }\n\n    /// @dev Checks that the emergencyExit is not enabled.\n    ///\n    ///\n    modifier notEmergency() {\n        require(!emergencyExit, \"emergency pause enabled\");\n        _;\n    }\n\n    /// @dev Updates the active vault.\n    ///\n    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\n    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\n    ///\n    /// @param _adapter the adapter for the new active vault.\n    function _updateActiveVault(IVaultAdapter _adapter) internal {\n        require(\n            _adapter != IVaultAdapter(ZERO_ADDRESS),\n            \"Alchemist: active vault address cannot be 0x0.\"\n        );\n        require(_adapter.token() == token, \"Alchemist: token mismatch.\");\n\n        _vaults.push(\n            AlchemistVault.Data({adapter: _adapter, totalDeposited: 0})\n        );\n\n        emit ActiveVaultUpdated(_adapter);\n    }\n\n    /// @dev Recalls an amount of funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    /// @param _amount  the amount of funds to recall from the vault.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function _recallFunds(uint256 _vaultId, uint256 _amount)\n        internal\n        returns (uint256, uint256)\n    {\n        require(\n            emergencyExit ||\n                msg.sender == governance ||\n                _vaultId != _vaults.lastIndex(),\n            \"Alchemist: not an emergency, not governance, and user does not have permission to recall funds from active vault\"\n        );\n\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _vault.withdraw(\n            address(this),\n            _amount\n        );\n\n        emit FundsRecalled(_vaultId, _withdrawnAmount, _decreasedValue);\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Attempts to withdraw funds from the active vault to the recipient.\n    ///\n    /// Funds will be first withdrawn from this contracts balance and then from the active vault. This function\n    /// is different from `recallFunds` in that it reduces the total amount of deposited tokens by the decreased\n    /// value of the vault.\n    ///\n    /// @param _recipient the account to withdraw the funds to.\n    /// @param _amount    the amount of funds to withdraw.\n    function _withdrawFundsTo(address _recipient, uint256 _amount)\n        internal\n        returns (uint256, uint256)\n    {\n        // Pull the funds from the buffer.\n        uint256 _bufferedAmount = Math.min(\n            _amount,\n            token.balanceOf(address(this))\n        );\n\n        if (_recipient != address(this)) {\n            ICurveToken(address(token)).remove_liquidity_one_coin(\n                _bufferedAmount,\n                sourceIndex,\n                0,\n                _recipient\n            );\n        }\n\n        uint256 _totalWithdrawn = _bufferedAmount;\n        uint256 _totalDecreasedValue = _bufferedAmount;\n\n        uint256 _remainingAmount = _amount.sub(_bufferedAmount);\n\n        // Pull the remaining funds from the active vault.\n        if (_remainingAmount > 0) {\n            (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults\n                .last()\n                .withdraw(address(this), _remainingAmount);\n\n            ICurveToken(address(token)).remove_liquidity_one_coin(\n                _withdrawAmount,\n                sourceIndex,\n                0,\n                _recipient\n            );\n\n            _totalWithdrawn = _totalWithdrawn.add(_withdrawAmount);\n            _totalDecreasedValue = _totalDecreasedValue.add(_decreasedValue);\n        }\n\n        totalDeposited = totalDeposited.sub(_totalDecreasedValue);\n\n        return (_totalWithdrawn, _totalDecreasedValue);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/alchemist/CDP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {FixedPointMath} from \"../FixedPointMath.sol\";\nimport {IDetailedERC20} from \"../../interfaces/IDetailedERC20.sol\";\n\n// import \"hardhat/console.sol\";\n\n/// @title CDP\n///\n/// @dev A library which provides the CDP data struct and associated functions.\nlibrary CDP {\n    using CDP for Data;\n    using FixedPointMath for FixedPointMath.FixedDecimal;\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    struct Context {\n        FixedPointMath.FixedDecimal collateralizationLimit;\n        FixedPointMath.FixedDecimal accumulatedYieldWeight;\n    }\n\n    struct Data {\n        uint256 totalDeposited;\n        uint256 totalDebt;\n        uint256 totalCredit;\n        uint256 lastDeposit;\n        FixedPointMath.FixedDecimal lastAccumulatedYieldWeight;\n    }\n\n    function update(Data storage _self, Context storage _ctx) internal {\n        uint256 _earnedYield = _self.getEarnedYield(_ctx);\n        if (_earnedYield > _self.totalDebt) {\n            _self.totalCredit = _self.totalCredit.add(\n                _earnedYield.sub(_self.totalDebt)\n            );\n            _self.totalDebt = 0;\n        } else {\n            _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n        }\n        _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n    }\n\n    /// @dev Assures that the CDP is healthy.\n    ///\n    /// This function will revert if the CDP is unhealthy.\n    function checkHealth(\n        Data storage _self,\n        Context storage _ctx,\n        string memory _msg\n    ) internal view {\n        require(_self.isHealthy(_ctx), _msg);\n    }\n\n    /// @dev Gets if the CDP is considered healthy.\n    ///\n    /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.\n    ///\n    /// @return if the CDP is healthy.\n    function isHealthy(Data storage _self, Context storage _ctx)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            _ctx.collateralizationLimit.cmp(\n                _self.getCollateralizationRatio(_ctx)\n            ) <= 0;\n    }\n\n    function getUpdatedTotalDebt(Data storage _self, Context storage _ctx)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n        uint256 _currentTotalDebt = _self.totalDebt;\n\n        if (_unclaimedYield < _currentTotalDebt) {\n            return _currentTotalDebt - _unclaimedYield;\n        }\n\n        return 0;\n    }\n\n    function getUpdatedTotalCredit(Data storage _self, Context storage _ctx)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n        if (_unclaimedYield == 0) {\n            return _self.totalCredit;\n        }\n\n        uint256 _currentTotalDebt = _self.totalDebt;\n        if (_unclaimedYield <= _currentTotalDebt) {\n            return 0;\n        }\n\n        return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);\n    }\n\n    /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.\n    ///\n    /// @param _self the CDP to query.\n    /// @param _ctx  the CDP context.\n    ///\n    /// @return the amount of earned yield.\n    function getEarnedYield(Data storage _self, Context storage _ctx)\n        internal\n        view\n        returns (uint256)\n    {\n        FixedPointMath.FixedDecimal memory _currentAccumulatedYieldWeight = _ctx\n            .accumulatedYieldWeight;\n        FixedPointMath.FixedDecimal memory _lastAccumulatedYieldWeight = _self\n            .lastAccumulatedYieldWeight;\n\n        if (\n            _currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0\n        ) {\n            return 0;\n        }\n\n        return\n            _currentAccumulatedYieldWeight\n                .sub(_lastAccumulatedYieldWeight)\n                .mul(_self.totalDeposited)\n                .decode();\n    }\n\n    /// @dev Gets a CDPs collateralization ratio.\n    ///\n    /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this\n    /// will return the maximum value of a fixed point integer.\n    ///\n    /// This function will use the updated total debt so an update before calling this function is not required.\n    ///\n    /// @param _self the CDP to query.\n    ///\n    /// @return a fixed point integer representing the collateralization ratio.\n    function getCollateralizationRatio(Data storage _self, Context storage _ctx)\n        internal\n        view\n        returns (FixedPointMath.FixedDecimal memory)\n    {\n        uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);\n        if (_totalDebt == 0) {\n            return FixedPointMath.maximumValue();\n        }\n        return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);\n    }\n}\n"
    },
    "contracts/libraries/FixedPointMath.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.6.12;\n\nlibrary FixedPointMath {\n  uint256 public constant DECIMALS = 18;\n  uint256 public constant SCALAR = 10**DECIMALS;\n\n  struct FixedDecimal {\n    uint256 x;\n  }\n\n  function fromU256(uint256 value) internal pure returns (FixedDecimal memory) {\n    uint256 x;\n    require(value == 0 || (x = value * SCALAR) / SCALAR == value);\n    return FixedDecimal(x);\n  }\n\n  function maximumValue() internal pure returns (FixedDecimal memory) {\n    return FixedDecimal(uint256(-1));\n  }\n\n  function add(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (FixedDecimal memory) {\n    uint256 x;\n    require((x = self.x + value.x) >= self.x);\n    return FixedDecimal(x);\n  }\n\n  function add(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {\n    return add(self, fromU256(value));\n  }\n\n  function sub(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (FixedDecimal memory) {\n    uint256 x;\n    require((x = self.x - value.x) <= self.x);\n    return FixedDecimal(x);\n  }\n\n  function sub(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {\n    return sub(self, fromU256(value));\n  }\n\n  function mul(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {\n    uint256 x;\n    require(value == 0 || (x = self.x * value) / value == self.x);\n    return FixedDecimal(x);\n  }\n\n  function div(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {\n    require(value != 0);\n    return FixedDecimal(self.x / value);\n  }\n\n  function cmp(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (int256) {\n    if (self.x < value.x) {\n      return -1;\n    }\n\n    if (self.x > value.x) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  function decode(FixedDecimal memory self) internal pure returns (uint256) {\n    return self.x / SCALAR;\n  }\n}"
    },
    "contracts/libraries/alchemist/AlchemistVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IDetailedERC20} from \"../../interfaces/IDetailedERC20.sol\";\nimport {IVaultAdapter} from \"../../interfaces/IVaultAdapter.sol\";\n\n// import \"hardhat/console.sol\";\n\n/// @title Pool\n///\n/// @dev A library which provides the AlchemistVault data struct and associated functions.\nlibrary AlchemistVault {\n    using AlchemistVault for Data;\n    using AlchemistVault for List;\n    using SafeERC20 for IDetailedERC20;\n    using SafeMath for uint256;\n\n    struct Data {\n        IVaultAdapter adapter;\n        uint256 totalDeposited;\n    }\n\n    struct List {\n        Data[] elements;\n    }\n\n    /// @dev Gets the total amount of assets deposited in the vault.\n    ///\n    /// @return the total assets.\n    function totalValue(Data storage _self) internal view returns (uint256) {\n        return _self.adapter.totalValue();\n    }\n\n    /// @dev Gets the token that the vault accepts.\n    ///\n    /// @return the accepted token.\n    function token(Data storage _self) internal view returns (IDetailedERC20) {\n        return IDetailedERC20(_self.adapter.token());\n    }\n\n    /// @dev Deposits funds from the caller into the vault.\n    ///\n    /// @param _amount the amount of funds to deposit.\n    function deposit(Data storage _self, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        // Push the token that the vault accepts onto the stack to save gas.\n        IDetailedERC20 _token = _self.token();\n\n        _token.safeTransfer(address(_self.adapter), _amount);\n        _self.adapter.deposit(_amount);\n        _self.totalDeposited = _self.totalDeposited.add(_amount);\n\n        return _amount;\n    }\n\n    /// @dev Deposits the entire token balance of the caller into the vault.\n    function depositAll(Data storage _self) internal returns (uint256) {\n        IDetailedERC20 _token = _self.token();\n        return _self.deposit(_token.balanceOf(address(this)));\n    }\n\n    /// @dev Withdraw deposited funds from the vault.\n    ///\n    /// @param _recipient the account to withdraw the tokens to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function withdraw(\n        Data storage _self,\n        address _recipient,\n        uint256 _amount\n    ) internal returns (uint256, uint256) {\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _self\n            .directWithdraw(_recipient, _amount);\n        _self.totalDeposited = _self.totalDeposited.sub(_decreasedValue);\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Directly withdraw deposited funds from the vault.\n    ///\n    /// @param _recipient the account to withdraw the tokens to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function directWithdraw(\n        Data storage _self,\n        address _recipient,\n        uint256 _amount\n    ) internal returns (uint256, uint256) {\n        IDetailedERC20 _token = _self.token();\n\n        uint256 _startingBalance = _token.balanceOf(_recipient);\n        uint256 _startingTotalValue = _self.totalValue();\n\n        _self.adapter.withdraw(_recipient, _amount);\n\n        uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(\n            _startingBalance\n        );\n        uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue());\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Withdraw all the deposited funds from the vault.\n    ///\n    /// @param _recipient the account to withdraw the tokens to.\n    function withdrawAll(Data storage _self, address _recipient)\n        internal\n        returns (uint256, uint256)\n    {\n        return _self.withdraw(_recipient, _self.totalDeposited);\n    }\n\n    /// @dev Harvests yield from the vault.\n    ///\n    /// @param _recipient the account to withdraw the harvested yield to.\n    function harvest(Data storage _self, address _recipient)\n        internal\n        returns (uint256, uint256)\n    {\n        if (_self.totalValue() <= _self.totalDeposited) {\n            return (0, 0);\n        }\n        uint256 _withdrawAmount = _self.totalValue().sub(_self.totalDeposited);\n        return _self.directWithdraw(_recipient, _withdrawAmount);\n    }\n\n    /// @dev Adds a element to the list.\n    ///\n    /// @param _element the element to add.\n    function push(List storage _self, Data memory _element) internal {\n        _self.elements.push(_element);\n    }\n\n    /// @dev Gets a element from the list.\n    ///\n    /// @param _index the index in the list.\n    ///\n    /// @return the element at the specified index.\n    function get(List storage _self, uint256 _index)\n        internal\n        view\n        returns (Data storage)\n    {\n        return _self.elements[_index];\n    }\n\n    /// @dev Gets the last element in the list.\n    ///\n    /// This function will revert if there are no elements in the list.\n    ///\n    /// @return the last element in the list.\n    function last(List storage _self) internal view returns (Data storage) {\n        return _self.elements[_self.lastIndex()];\n    }\n\n    /// @dev Gets the index of the last element in the list.\n    ///\n    /// This function will revert if there are no elements in the list.\n    ///\n    /// @return the index of the last element.\n    function lastIndex(List storage _self) internal view returns (uint256) {\n        uint256 _length = _self.length();\n        return _length.sub(1, \"AlchemistVault.List: empty\");\n    }\n\n    /// @dev Gets the number of elements in the list.\n    ///\n    /// @return the number of elements.\n    function length(List storage _self) internal view returns (uint256) {\n        return _self.elements.length;\n    }\n}\n"
    },
    "contracts/interfaces/ITransmuter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\ninterface ITransmuter  {\n  function distribute (address origin, uint256 amount) external;\n}"
    },
    "contracts/interfaces/IMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n\nimport {IDetailedERC20} from \"./IDetailedERC20.sol\";\n\ninterface IMintableERC20 is IDetailedERC20{\n  function mint(address _recipient, uint256 _amount) external;\n  function burnFrom(address account, uint256 amount) external;\n  function lowerHasMinted(uint256 amount)external;\n}\n"
    },
    "contracts/interfaces/ICurveToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\ninterface ICurveToken {\n    function add_liquidity(\n        uint256[2] calldata token_amount,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        int128 i,\n        uint256 min_amount,\n        address receiver\n    ) external returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n"
    },
    "contracts/Alchemist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n//import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {CDP} from \"./libraries/alchemist/CDP.sol\";\nimport {FixedPointMath} from \"./libraries/FixedPointMath.sol\";\nimport {AlchemistVault} from \"./libraries/alchemist/AlchemistVault.sol\";\nimport {ITransmuter} from \"./interfaces/ITransmuter.sol\";\nimport {IMintableERC20} from \"./interfaces/IMintableERC20.sol\";\nimport {ICurveToken} from \"./interfaces/ICurveToken.sol\";\nimport {IVaultAdapter} from \"./interfaces/IVaultAdapter.sol\";\n\n// ERC20,removing ERC20 from the alchemist\n//    ___    __        __                _               ___                              __         _\n//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \\  ____ ___   ___ ___   ___  / /_  ___  (_)\n//  / __ | / / / __/ / _ \\/ -_) /  ' \\ / /  \\ \\ /      / ___/ / __// -_) (_-</ -_) / _ \\/ __/ (_-< _\n// /_/ |_|/_/  \\__/ /_//_/\\__/ /_/_/_//_/  /_\\_\\      /_/    /_/   \\__/ /___/\\__/ /_//_/\\__/ /___/(_)\n//\n//      ___       __        ______  __    __   _______ .___  ___.  __       _______..___________.\n//     /   \\     |  |      /      ||  |  |  | |   ____||   \\/   | |  |     /       ||           |\n//    /  ^  \\    |  |     |  ,----'|  |__|  | |  |__   |  \\  /  | |  |    |   (----``---|  |----`\n//   /  /_\\  \\   |  |     |  |     |   __   | |   __|  |  |\\/|  | |  |     \\   \\        |  |\n//  /  _____  \\  |  `----.|  `----.|  |  |  | |  |____ |  |  |  | |  | .----)   |       |  |\n// /__/     \\__\\ |_______| \\______||__|  |__| |_______||__|  |__| |__| |_______/        |__|\n\ncontract Alchemist is ReentrancyGuard {\n    using CDP for CDP.Data;\n    using FixedPointMath for FixedPointMath.FixedDecimal;\n    using AlchemistVault for AlchemistVault.Data;\n    using AlchemistVault for AlchemistVault.List;\n    using SafeERC20 for IMintableERC20;\n    using SafeMath for uint256;\n    using Address for address;\n\n    address public constant ZERO_ADDRESS = address(0);\n\n    /// @dev Resolution for all fixed point numeric parameters which represent percents. The resolution allows for a\n    /// granularity of 0.01% increments.\n    uint256 public constant PERCENT_RESOLUTION = 10000;\n\n    /// @dev The minimum value that the collateralization limit can be set to by the governance. This is a safety rail\n    /// to prevent the collateralization from being set to a value which breaks the system.\n    ///\n    /// This value is equal to 100%.\n    ///\n    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the\n    ///            resolution for the FixedPointMath library changes this constant must change as well.\n    uint256 public constant MINIMUM_COLLATERALIZATION_LIMIT =\n        1000000000000000000;\n\n    /// @dev The maximum value that the collateralization limit can be set to by the governance. This is a safety rail\n    /// to prevent the collateralization from being set to a value which breaks the system.\n    ///\n    /// This value is equal to 400%.\n    ///\n    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the\n    ///            resolution for the FixedPointMath library changes this constant must change as well.\n    uint256 public constant MAXIMUM_COLLATERALIZATION_LIMIT =\n        4000000000000000000;\n\n    event GovernanceUpdated(address governance);\n\n    event PendingGovernanceUpdated(address pendingGovernance);\n\n    event SentinelUpdated(address sentinel);\n\n    event TransmuterUpdated(address transmuter);\n\n    event RewardsUpdated(address treasury);\n\n    event HarvestFeeUpdated(uint256 fee);\n\n    event BorrowFeeUpdated(uint256 fee);\n\n    event CollateralizationLimitUpdated(uint256 limit);\n\n    event PegMinimumUpdated(uint256 pegMinimum);\n\n    event EmergencyExitUpdated(bool status);\n\n    event ActiveVaultUpdated(IVaultAdapter indexed adapter);\n\n    event FundsHarvested(uint256 withdrawnAmount, uint256 decreasedValue);\n\n    event FundsRecalled(\n        uint256 indexed vaultId,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    event FundsFlushed(uint256 amount);\n\n    event TokensDeposited(address indexed account, uint256 amount);\n\n    event TokensWithdrawn(\n        address indexed account,\n        uint256 requestedAmount,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    event TokensRepaid(\n        address indexed account,\n        uint256 parentAmount,\n        uint256 childAmount\n    );\n\n    event TokensLiquidated(\n        address indexed account,\n        uint256 requestedAmount,\n        uint256 withdrawnAmount,\n        uint256 decreasedValue\n    );\n\n    /// @dev The token that this contract is using as the parent asset.\n    IMintableERC20 public token;\n\n    /// @dev The token that this contract is using as the child asset.\n    IMintableERC20 public xtoken;\n\n    /// @dev The address of the account which currently has administrative capabilities over this contract.\n    address public governance;\n\n    /// @dev The address of the pending governance.\n    address public pendingGovernance;\n\n    /// @dev The address of the account which can initiate an emergency withdraw of funds in a vault.\n    address public sentinel;\n\n    /// @dev The address of the contract which will transmute synthetic tokens back into native tokens.\n    address public transmuter;\n\n    /// @dev The address of the contract which will receive fees.\n    address public rewards;\n\n    /// @dev The percent of each profitable harvest that will go to the rewards contract.\n    uint256 public harvestFee;\n\n    /// @dev The percent of minted debt that will go to the rewards contract.\n    uint256 public borrowFee;\n\n    /// @dev The total amount the native token deposited into the system that is owned by external users.\n    uint256 public totalDeposited;\n\n    /// @dev when movemetns are bigger than this number flush is activated.\n    uint256 public flushActivator;\n\n    /// @dev A flag indicating if the contract has been initialized yet.\n    bool public initialized;\n\n    /// @dev A flag indicating if deposits and flushes should be halted and if all parties should be able to recall\n    /// from the active vault.\n    bool public emergencyExit;\n\n    /// @dev The context shared between the CDPs.\n    CDP.Context private _ctx;\n\n    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either\n    /// create a new address.\n    mapping(address => CDP.Data) private _cdps;\n\n    /// @dev A list of all of the vaults. The last element of the list is the vault that is currently being used for\n    /// deposits and withdraws. Vaults before the last element are considered inactive and are expected to be cleared.\n    AlchemistVault.List private _vaults;\n\n    /// @dev The minimum returned amount needed to be on peg according to the oracle.\n    uint256 public pegMinimum;\n\n    constructor(\n        IMintableERC20 _token,\n        IMintableERC20 _xtoken,\n        address _governance,\n        address _sentinel\n    )\n        public\n    /*ERC20(\n      string(abi.encodePacked(\"Alchemic \", _token.name())),\n      string(abi.encodePacked(\"al\", _token.symbol()))\n    )*/\n    {\n        require(\n            _governance != ZERO_ADDRESS,\n            \"Alchemist: governance address cannot be 0x0.\"\n        );\n        require(\n            _sentinel != ZERO_ADDRESS,\n            \"Alchemist: sentinel address cannot be 0x0.\"\n        );\n\n        token = _token;\n        xtoken = _xtoken;\n        governance = _governance;\n        sentinel = _sentinel;\n        flushActivator = 100000 ether; // change for non 18 digit tokens\n\n        //_setupDecimals(_token.decimals());\n        uint256 COLL_LIMIT = MINIMUM_COLLATERALIZATION_LIMIT.mul(2);\n        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(COLL_LIMIT);\n        _ctx.accumulatedYieldWeight = FixedPointMath.FixedDecimal(0);\n    }\n\n    /// @dev Sets the pending governance.\n    ///\n    /// This function reverts if the new pending governance is the zero address or the caller is not the current\n    /// governance. This is to prevent the contract governance being set to the zero address which would deadlock\n    /// privileged contract functionality.\n    ///\n    /// @param _pendingGovernance the new pending governance.\n    function setPendingGovernance(address _pendingGovernance) external onlyGov {\n        require(\n            _pendingGovernance != ZERO_ADDRESS,\n            \"Alchemist: governance address cannot be 0x0.\"\n        );\n\n        pendingGovernance = _pendingGovernance;\n\n        emit PendingGovernanceUpdated(_pendingGovernance);\n    }\n\n    /// @dev Accepts the role as governance.\n    ///\n    /// This function reverts if the caller is not the new pending governance.\n    function acceptGovernance() external {\n        address _pendingGovernance = pendingGovernance;\n        require(\n            msg.sender == _pendingGovernance,\n            \"sender is not pendingGovernance\"\n        );\n        governance = _pendingGovernance;\n\n        emit GovernanceUpdated(_pendingGovernance);\n    }\n\n    function setSentinel(address _sentinel) external onlyGov {\n        require(\n            _sentinel != ZERO_ADDRESS,\n            \"Alchemist: sentinel address cannot be 0x0.\"\n        );\n\n        sentinel = _sentinel;\n\n        emit SentinelUpdated(_sentinel);\n    }\n\n    /// @dev Sets the transmuter.\n    ///\n    /// This function reverts if the new transmuter is the zero address or the caller is not the current governance.\n    ///\n    /// @param _transmuter the new transmuter.\n    function setTransmuter(address _transmuter) external onlyGov {\n        // Check that the transmuter address is not the zero address. Setting the transmuter to the zero address would break\n        // transfers to the address because of `safeTransfer` checks.\n        require(\n            _transmuter != ZERO_ADDRESS,\n            \"Alchemist: transmuter address cannot be 0x0.\"\n        );\n\n        transmuter = _transmuter;\n\n        emit TransmuterUpdated(_transmuter);\n    }\n\n    /// @dev Sets the flushActivator.\n    ///\n    /// @param _flushActivator the new flushActivator.\n    function setFlushActivator(uint256 _flushActivator) external onlyGov {\n        flushActivator = _flushActivator;\n    }\n\n    /// @dev Sets the rewards contract.\n    ///\n    /// This function reverts if the new rewards contract is the zero address or the caller is not the current governance.\n    ///\n    /// @param _rewards the new rewards contract.\n    function setRewards(address _rewards) external onlyGov {\n        // Check that the rewards address is not the zero address. Setting the rewards to the zero address would break\n        // transfers to the address because of `safeTransfer` checks.\n        require(\n            _rewards != ZERO_ADDRESS,\n            \"Alchemist: rewards address cannot be 0x0.\"\n        );\n\n        rewards = _rewards;\n\n        emit RewardsUpdated(_rewards);\n    }\n\n    /// @dev Sets the harvest fee.\n    ///\n    /// This function reverts if the caller is not the current governance.\n    ///\n    /// @param _harvestFee the new harvest fee.\n    function setHarvestFee(uint256 _harvestFee) external onlyGov {\n        // Check that the harvest fee is within the acceptable range. Setting the harvest fee greater than 100% could\n        // potentially break internal logic when calculating the harvest fee.\n        require(\n            _harvestFee <= PERCENT_RESOLUTION,\n            \"Alchemist: harvest fee above maximum.\"\n        );\n\n        harvestFee = _harvestFee;\n\n        emit HarvestFeeUpdated(_harvestFee);\n    }\n\n    /// @dev Sets the borrow fee.\n    ///\n    /// This function reverts if the caller is not the current governance.\n    ///\n    /// @param _borrowFee the new borrow fee.\n    function setBorrowFee(uint256 _borrowFee) external onlyGov {\n        // Check that the borrow fee is within the acceptable range. Setting the borrow fee greater than 100% could\n        // potentially break internal logic when calculating the borrow fee.\n        require(\n            _borrowFee <= PERCENT_RESOLUTION,\n            \"Alchemist: borrow fee above maximum.\"\n        );\n\n        borrowFee = _borrowFee;\n\n        emit BorrowFeeUpdated(_borrowFee);\n    }\n\n    /// @dev Sets the collateralization limit.\n    ///\n    /// This function reverts if the caller is not the current governance or if the collateralization limit is outside\n    /// of the accepted bounds.\n    ///\n    /// @param _limit the new collateralization limit.\n    function setCollateralizationLimit(uint256 _limit) external onlyGov {\n        require(\n            _limit >= MINIMUM_COLLATERALIZATION_LIMIT,\n            \"Alchemist: collateralization limit below minimum.\"\n        );\n        require(\n            _limit <= MAXIMUM_COLLATERALIZATION_LIMIT,\n            \"Alchemist: collateralization limit above maximum.\"\n        );\n\n        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(_limit);\n\n        emit CollateralizationLimitUpdated(_limit);\n    }\n\n    /// @dev Set pegMinimum.\n    function setPegMinimum(uint256 peg) external onlyGov {\n        pegMinimum = peg;\n        emit PegMinimumUpdated(pegMinimum);\n    }\n\n    /// @dev Sets if the contract should enter emergency exit mode.\n    ///\n    /// @param _emergencyExit if the contract should enter emergency exit mode.\n    function setEmergencyExit(bool _emergencyExit) external {\n        require(msg.sender == governance || msg.sender == sentinel, \"\");\n\n        emergencyExit = _emergencyExit;\n\n        emit EmergencyExitUpdated(_emergencyExit);\n    }\n\n    /// @dev Gets the collateralization limit.\n    ///\n    /// The collateralization limit is the minimum ratio of collateral to debt that is allowed by the system.\n    ///\n    /// @return the collateralization limit.\n    function collateralizationLimit()\n        external\n        view\n        returns (FixedPointMath.FixedDecimal memory)\n    {\n        return _ctx.collateralizationLimit;\n    }\n\n    /// @dev Initializes the contract.\n    ///\n    /// This function checks that the transmuter and rewards have been set and sets up the active vault.\n    ///\n    /// @param _adapter the vault adapter of the active vault.\n    function initialize(IVaultAdapter _adapter) external onlyGov {\n        require(!initialized, \"Alchemist: already initialized\");\n\n        require(\n            transmuter != ZERO_ADDRESS,\n            \"Alchemist: cannot initialize transmuter address to 0x0\"\n        );\n        require(\n            rewards != ZERO_ADDRESS,\n            \"Alchemist: cannot initialize rewards address to 0x0\"\n        );\n\n        _updateActiveVault(_adapter);\n\n        initialized = true;\n    }\n\n    /// @dev Migrates the system to a new vault.\n    ///\n    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\n    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\n    ///\n    /// @param _adapter the adapter for the vault the system will migrate to.\n    function migrate(IVaultAdapter _adapter)\n        external\n        expectInitialized\n        onlyGov\n    {\n        _updateActiveVault(_adapter);\n    }\n\n    /// @dev Harvests yield from a vault.\n    ///\n    /// @param _vaultId the identifier of the vault to harvest from.\n    ///\n    /// @return the amount of funds that were harvested from the vault.\n    function harvest(uint256 _vaultId)\n        external\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n\n        (uint256 _harvestedAmount, uint256 _decreasedValue) = _vault.harvest(\n            address(this)\n        );\n\n        if (_harvestedAmount > 0) {\n            uint256 _feeAmount = _harvestedAmount.mul(harvestFee).div(\n                PERCENT_RESOLUTION\n            );\n            uint256 _distributeAmount = _harvestedAmount.sub(_feeAmount);\n\n            FixedPointMath.FixedDecimal memory _weight = FixedPointMath\n                .fromU256(_distributeAmount)\n                .div(totalDeposited);\n            _ctx.accumulatedYieldWeight = _ctx.accumulatedYieldWeight.add(\n                _weight\n            );\n\n            if (_feeAmount > 0) {\n                token.safeTransfer(rewards, _feeAmount);\n            }\n\n            if (_distributeAmount > 0) {\n                _distributeToTransmuter(_distributeAmount);\n\n                // token.safeTransfer(transmuter, _distributeAmount); previous version call\n            }\n        }\n\n        emit FundsHarvested(_harvestedAmount, _decreasedValue);\n\n        return (_harvestedAmount, _decreasedValue);\n    }\n\n    /// @dev Recalls an amount of deposited funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function recall(uint256 _vaultId, uint256 _amount)\n        external\n        nonReentrant\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        return _recallFunds(_vaultId, _amount);\n    }\n\n    /// @dev Recalls all the deposited funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function recallAll(uint256 _vaultId)\n        external\n        nonReentrant\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _recallFunds(_vaultId, _vault.totalDeposited);\n    }\n\n    /// @dev Flushes buffered tokens to the active vault.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @return the amount of tokens flushed to the active vault.\n    function flush()\n        external\n        nonReentrant\n        notEmergency\n        expectInitialized\n        returns (uint256)\n    {\n        // Prevent flushing to the active vault when an emergency exit is enabled to prevent potential loss of funds if\n        // the active vault is poisoned for any reason.\n        return flushActiveVault();\n    }\n\n    /// @dev Internal function to flush buffered tokens to the active vault.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @return the amount of tokens flushed to the active vault.\n    function flushActiveVault() internal returns (uint256) {\n        AlchemistVault.Data storage _activeVault = _vaults.last();\n        uint256 _depositedAmount = _activeVault.depositAll();\n\n        emit FundsFlushed(_depositedAmount);\n\n        return _depositedAmount;\n    }\n\n    /// @dev Deposits collateral into a CDP.\n    ///\n    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of\n    /// additional funds.\n    ///\n    /// @param _amount the amount of collateral to deposit.\n    function deposit(uint256 _amount)\n        external\n        nonReentrant\n        notEmergency\n        noContractAllowed\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        if (_amount >= flushActivator) {\n            flushActiveVault();\n        }\n        totalDeposited = totalDeposited.add(_amount);\n\n        _cdp.totalDeposited = _cdp.totalDeposited.add(_amount);\n        _cdp.lastDeposit = block.number;\n\n        emit TokensDeposited(msg.sender, _amount);\n    }\n\n    /// @dev Attempts to withdraw part of a CDP's collateral.\n    ///\n    /// This function reverts if a deposit into the CDP was made in the same block. This is to prevent flash loan attacks\n    /// on other internal or external systems.\n    ///\n    /// @param _amount the amount of collateral to withdraw.\n    function withdraw(uint256 _amount)\n        external\n        nonReentrant\n        noContractAllowed\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        require(block.number > _cdp.lastDeposit, \"\");\n\n        _cdp.update(_ctx);\n\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(\n            msg.sender,\n            _amount\n        );\n\n        _cdp.totalDeposited = _cdp.totalDeposited.sub(\n            _decreasedValue,\n            \"Exceeds withdrawable amount\"\n        );\n        _cdp.checkHealth(\n            _ctx,\n            \"Action blocked: unhealthy collateralization ratio\"\n        );\n        if (_amount >= flushActivator) {\n            flushActiveVault();\n        }\n        emit TokensWithdrawn(\n            msg.sender,\n            _amount,\n            _withdrawnAmount,\n            _decreasedValue\n        );\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Repays debt with the native and or synthetic token.\n    ///\n    /// An approval is required to transfer native tokens to the transmuter.\n    function repay(uint256 _parentAmount, uint256 _childAmount)\n        external\n        nonReentrant\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        if (_parentAmount > 0) {\n            token.safeTransferFrom(msg.sender, address(this), _parentAmount);\n            _distributeToTransmuter(_parentAmount);\n        }\n\n        if (_childAmount > 0) {\n            xtoken.burnFrom(msg.sender, _childAmount);\n            //lower debt cause burn\n            xtoken.lowerHasMinted(_childAmount);\n        }\n\n        uint256 _totalAmount = _parentAmount.add(_childAmount);\n        _cdp.totalDebt = _cdp.totalDebt.sub(_totalAmount, \"\");\n\n        emit TokensRepaid(msg.sender, _parentAmount, _childAmount);\n    }\n\n    /// @dev Attempts to liquidate part of a CDP's collateral to pay back its debt.\n    ///\n    /// @param _amount the amount of collateral to attempt to liquidate.\n    function liquidate(uint256 _amount)\n        external\n        nonReentrant\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n        returns (uint256, uint256)\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        // don't attempt to liquidate more than is possible\n        if (_amount > _cdp.totalDebt) {\n            _amount = _cdp.totalDebt;\n        }\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(\n            address(this),\n            _amount\n        );\n        //changed to new transmuter compatibillity\n        _distributeToTransmuter(_withdrawnAmount);\n\n        _cdp.totalDeposited = _cdp.totalDeposited.sub(_decreasedValue, \"\");\n        _cdp.totalDebt = _cdp.totalDebt.sub(_withdrawnAmount, \"\");\n        emit TokensLiquidated(\n            msg.sender,\n            _amount,\n            _withdrawnAmount,\n            _decreasedValue\n        );\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Mints synthetic tokens by either claiming credit or increasing the debt.\n    ///\n    /// Claiming credit will take priority over increasing the debt.\n    ///\n    /// This function reverts if the debt is increased and the CDP health check fails.\n    ///\n    /// @param _amount the amount of alchemic tokens to borrow.\n    function mint(uint256 _amount)\n        external\n        nonReentrant\n        notEmergency\n        noContractAllowed\n        onPriceCheck\n        expectInitialized\n    {\n        CDP.Data storage _cdp = _cdps[msg.sender];\n        _cdp.update(_ctx);\n\n        uint256 _totalCredit = _cdp.totalCredit;\n\n        if (_totalCredit < _amount) {\n            uint256 _remainingAmount = _amount - _totalCredit;\n\n            if (borrowFee > 0) {\n                uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(\n                    PERCENT_RESOLUTION\n                );\n                _remainingAmount = _remainingAmount.add(_borrowFeeAmount);\n                xtoken.mint(rewards, _borrowFeeAmount);\n            }\n            _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);\n            _cdp.totalCredit = 0;\n\n            _cdp.checkHealth(_ctx, \"Alchemist: Loan-to-value ratio breached\");\n        } else {\n            _cdp.totalCredit = _totalCredit.sub(_amount);\n        }\n\n        xtoken.mint(msg.sender, _amount);\n        if (_amount >= flushActivator) {\n            flushActiveVault();\n        }\n    }\n\n    /// @dev Gets the number of vaults in the vault list.\n    ///\n    /// @return the vault count.\n    function vaultCount() external view returns (uint256) {\n        return _vaults.length();\n    }\n\n    /// @dev Get the adapter of a vault.\n    ///\n    /// @param _vaultId the identifier of the vault.\n    ///\n    /// @return the vault adapter.\n    function getVaultAdapter(uint256 _vaultId)\n        external\n        view\n        returns (IVaultAdapter)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _vault.adapter;\n    }\n\n    /// @dev Get the total amount of the parent asset that has been deposited into a vault.\n    ///\n    /// @param _vaultId the identifier of the vault.\n    ///\n    /// @return the total amount of deposited tokens.\n    function getVaultTotalDeposited(uint256 _vaultId)\n        external\n        view\n        returns (uint256)\n    {\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        return _vault.totalDeposited;\n    }\n\n    /// @dev Get the total amount of collateral deposited into a CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the deposited amount of tokens.\n    function getCdpTotalDeposited(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.totalDeposited;\n    }\n\n    /// @dev Get the total amount of alchemic tokens borrowed from a CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the borrowed amount of tokens.\n    function getCdpTotalDebt(address _account) external view returns (uint256) {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.getUpdatedTotalDebt(_ctx);\n    }\n\n    /// @dev Get the total amount of credit that a CDP has.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the amount of credit.\n    function getCdpTotalCredit(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.getUpdatedTotalCredit(_ctx);\n    }\n\n    /// @dev Gets the last recorded block of when a user made a deposit into their CDP.\n    ///\n    /// @param _account the user account of the CDP to query.\n    ///\n    /// @return the block number of the last deposit.\n    function getCdpLastDeposit(address _account)\n        external\n        view\n        returns (uint256)\n    {\n        CDP.Data storage _cdp = _cdps[_account];\n        return _cdp.lastDeposit;\n    }\n\n    /// @dev sends tokens to the transmuter\n    ///\n    /// benefit of great nation of transmuter\n    function _distributeToTransmuter(uint256 amount) internal {\n        token.approve(transmuter, amount);\n        ITransmuter(transmuter).distribute(address(this), amount);\n        // lower debt cause of 'burn'\n        xtoken.lowerHasMinted(amount);\n    }\n\n    /// @dev Checks that parent token is on peg.\n    ///\n    /// This is used over a modifier limit of pegged interactions.\n    modifier onPriceCheck() {\n        if (pegMinimum > 0) {\n            require(\n                ICurveToken(address(token)).get_virtual_price() > pegMinimum,\n                \"off peg limitation\"\n            );\n        }\n        _;\n    }\n    /// @dev Checks that caller is not a contract.\n    ///\n    /// This is used to prevent contracts from interacting.\n    modifier noContractAllowed() {\n        require(\n            !address(msg.sender).isContract() && msg.sender == tx.origin,\n            \"Sorry we do not accept contract!\"\n        );\n        _;\n    }\n    /// @dev Checks that the contract is in an initialized state.\n    ///\n    /// This is used over a modifier to reduce the size of the contract\n    modifier expectInitialized() {\n        require(initialized, \"Alchemist: not initialized.\");\n        _;\n    }\n\n    /// @dev Checks that the current message sender or caller is the governance address.\n    ///\n    ///\n    modifier onlyGov() {\n        require(msg.sender == governance, \"Alchemist: only governance.\");\n        _;\n    }\n\n    /// @dev Checks that the emergencyExit is not enabled.\n    ///\n    ///\n    modifier notEmergency() {\n        require(!emergencyExit, \"emergency pause enabled\");\n        _;\n    }\n\n    /// @dev Updates the active vault.\n    ///\n    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts\n    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.\n    ///\n    /// @param _adapter the adapter for the new active vault.\n    function _updateActiveVault(IVaultAdapter _adapter) internal {\n        require(\n            _adapter != IVaultAdapter(ZERO_ADDRESS),\n            \"Alchemist: active vault address cannot be 0x0.\"\n        );\n        require(_adapter.token() == token, \"Alchemist: token mismatch.\");\n\n        _vaults.push(\n            AlchemistVault.Data({adapter: _adapter, totalDeposited: 0})\n        );\n\n        emit ActiveVaultUpdated(_adapter);\n    }\n\n    /// @dev Recalls an amount of funds from a vault to this contract.\n    ///\n    /// @param _vaultId the identifier of the recall funds from.\n    /// @param _amount  the amount of funds to recall from the vault.\n    ///\n    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.\n    function _recallFunds(uint256 _vaultId, uint256 _amount)\n        internal\n        returns (uint256, uint256)\n    {\n        require(\n            emergencyExit ||\n                msg.sender == governance ||\n                _vaultId != _vaults.lastIndex(),\n            \"Alchemist: not an emergency, not governance, and user does not have permission to recall funds from active vault\"\n        );\n\n        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);\n        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _vault.withdraw(\n            address(this),\n            _amount\n        );\n\n        emit FundsRecalled(_vaultId, _withdrawnAmount, _decreasedValue);\n\n        return (_withdrawnAmount, _decreasedValue);\n    }\n\n    /// @dev Attempts to withdraw funds from the active vault to the recipient.\n    ///\n    /// Funds will be first withdrawn from this contracts balance and then from the active vault. This function\n    /// is different from `recallFunds` in that it reduces the total amount of deposited tokens by the decreased\n    /// value of the vault.\n    ///\n    /// @param _recipient the account to withdraw the funds to.\n    /// @param _amount    the amount of funds to withdraw.\n    function _withdrawFundsTo(address _recipient, uint256 _amount)\n        internal\n        returns (uint256, uint256)\n    {\n        // Pull the funds from the buffer.\n        uint256 _bufferedAmount = Math.min(\n            _amount,\n            token.balanceOf(address(this))\n        );\n\n        if (_recipient != address(this)) {\n            token.safeTransfer(_recipient, _bufferedAmount);\n        }\n\n        uint256 _totalWithdrawn = _bufferedAmount;\n        uint256 _totalDecreasedValue = _bufferedAmount;\n\n        uint256 _remainingAmount = _amount.sub(_bufferedAmount);\n\n        // Pull the remaining funds from the active vault.\n        if (_remainingAmount > 0) {\n            (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults\n                .last()\n                .withdraw(_recipient, _remainingAmount);\n\n            _totalWithdrawn = _totalWithdrawn.add(_withdrawAmount);\n            _totalDecreasedValue = _totalDecreasedValue.add(_decreasedValue);\n        }\n\n        totalDeposited = totalDeposited.sub(_totalDecreasedValue);\n\n        return (_totalWithdrawn, _totalDecreasedValue);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @title ERC20Mock\n///\n/// @dev A mock of an ERC20 token which lets anyone burn and mint tokens.\ncontract ERC20Mock is ERC20 {\n\n  constructor(string memory _name, string memory _symbol, uint8 _decimals) public ERC20(_name, _symbol) {\n    _setupDecimals(_decimals);\n  }\n\n  function mint(address _recipient, uint256 _amount) external {\n    _mint(_recipient, _amount);\n  }\n\n  function burn(address _account, uint256 _amount) external {\n    _burn(_account, _amount);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}